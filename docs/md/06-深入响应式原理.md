

## 深入响应式原理



---

[TOC]

---

### 1. 响应式对象

​	`Vue` 的[响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)是核心是通过 `ES5` 的保护对象的 `Object.defindeProperty` 中的访问器属性中的 `get` 和 `set` 方法，`data` 中声明的属性都被添加了访问器属性，当读取 `data` 中的数据时自动调用 `get` 方法，当修改 `data` 中的数据时，自动调用 `set `方法，检测到数据的变化，会通知观察者 `Wacher`，观察者 `Wacher`自动触发重新`render` 当前组件（子组件不会重新渲染）,生成新的虚拟` DOM` 树，`Vue` 框架会遍历并对比新虚拟 `DOM` 树和旧虚拟 `DOM` 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实` DOM` 树上。

​	![深入响应式原理](https://cn.vuejs.org/images/data.png)

	#### 	1.1 `Object.defineProperty`

​		[`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

​		语法：

```js
Object.defineProperty(obj, prop, descriptor)
```

​		参数：

​			(1) obj：要在其上定义属性的对象。

​			(2) prop：要定义或修改的属性的名称。

​			(3) descriptor：将被定义或修改的属性描述符。

​	比较核心的是 `descriptor `，它有很多可选键值。这里我们最关心的是 `get` 和 `set` ， `get` 是一个给属性提供的 `getter` 方法，当我们访问了该属性的时候会触发 `getter` 方法; `set` 是一个给属性提供的` setter `方法，当我们对该属性做修改的时候会触发 `setter` 方法。 一旦对象拥有了 `getter` 和 `setter`，我们可以简单地把这个对象称为响应式对象。那么 Vue.js 把哪些对象变成了响应式对象了呢，接下来我们从源码层面分析。

​	源码目录：`src/core/instance/init.js`

```js
export function initMixin (Vue: Class<Component>) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // ...
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    // 初始化props属性、data属性、methods属性、computed属性、watch属性
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')
    // ...
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```



#### 		1.1 `initState`
​		源码目录：`src/core/instance/state.js`

```js
export function initState (vm: Component) {
  vm._watchers = []
  // new Vue(options) 中的 options
  const opts = vm.$options
  // 将props配置项中属性转化为vue实例的响应式属性
  if (opts.props) initProps(vm, opts.props)
  // 将 methods配置项中的方法添加到 vue实例对象中
  if (opts.methods) initMethods(vm, opts.methods)
  // 将data配置项中的属性转化为vue实例的响应式属性
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

​		从源码分析可以得出，这个方法主要是功能是初始化 `props` 属性、`data` 属性、`methods` 属性、`computed` 属性、`watch` 属性。

​		这个小节中我们主要分析 `props` 属性、`data` 属性。

##### 		1.1.1 `props`

​		源码目录：`src/core/instance/state.js`

```js
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false)
  }
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}
```

​			`initProps` 函数在初始化 `props` 的过程中主要执行一下几个步骤：

​				(1) 遍历定义的 `props` 配置；

​				(2) 调用 `defineReactive(props, key, value)` 方法把每个 `prop` 对应的值变成响应式，可以通过 `vm._props.xxx`访问到定义 `props` 中对应的属性；

​				(3) 通过 `proxy(vm, _props, key)` 把 `vm._props.xxx` 的访问代理到 `vm.xxx` 上。

		##### 		1.1.1 `data`

​			源码目录：`src/core/instance/state.js`

````js
function initData (vm: Component) {
  // 获取data配置项对象
  let data = vm.$options.data
  // 组件实例的data配置项是一个函数
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  // 获取data配置项的属性值
  const keys = Object.keys(data)
  // 获取props配置项的属性值
  const props = vm.$options.props
  // 获取methods配置项的属性值；
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      // methods配置项和data配置项中的属性不能同名
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    // props配置项和data配置项中的属性不能同名
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) { // 如果属性不是$,_ 开头(vue的保留属性)
      // 建立 vue实例 和 _data 的关联关系性
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  // 观察data对象， 将对象属性全部转化为响应式属性
  observe(data, true /* asRootData */)
}
````

​			`initData` 函数在初始化 `data` 的过程中主要执行一下几个步骤：

​				(1) 遍历定义的 `data` 配置；

​				(2) 通过 `proxy(vm, _data, key)` 把 `vm._data.xxx` 的访问代理到 `vm.xxx` 上；

​				(2) 调用 `observe(data, true /* asRootData */)` 方法观测整个 `data` 的变化，把 `data` 变成响应式，可以通过`vm._data.xxx` 访问到定义 `data` 返回函数中对应的属性。

#### 		1.2 `proxy`

​		`proxy` 的主要作用就是把 `props` 和 `data` 上的属性代理到 vm 实例上，这也就是为什么比如我们定义了如下 `props`，却可以通过 `vm` 实例访问到它。

```js
let App = {
  props: {
    msg: 'hello'
  },
  methods: {
    say() {
			console.log(this.msg) 
    }
  } 
}
```

​		如上面的例子，我们可以通过 `this.msg` 访问到，`props` 中定义的 `msg` 属性的值，这个功能的实现在 `proxy`中。

​		源码目录：`src/core/instance/state.js`

```js
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

​		`proxy` 作用是通过 `defineProperty` 方法， 给 `vue` 实例对象添加属性，提供属性的  `getter/setter`  方法，即把 `target[sourceKey][key]` 的读写变成 `target[key]`。

​		对 `props` 而言，对 `vm._props.xxx` 的读写变成了 `vm.xxx` 的读写，而对于 `vm._props.xxx ` 我们可以访问到定义在 `props` 中的属性，所以我们就可以通过 `vm.xxx` 访问到定义在 `props` 中的 `xxx` 属性了。

​		同理，对 `data` 而言，对 `vm._data.xxx` 的读写变成了 `vm.xxx` 的读写，而对于 `vm._data.xxx ` 我们可以访问到定义在 `data` 函数返回对象中的属性，所以我们就可以通过 `vm.xxx` 访问到定义在 `data` 函数返回对象中的 `xxx` 属性了。

#### 		1.3 `observe`

​		`observe` 的功能就是用来检测数据的变化。

​		源码目录：`src/core/observe/index.js`

```js

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}

```

​		`observe` 方法的作用就是给非 `VNode` 的对象类型数据添加一个 `Observer` ，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 `Observer` 对象实例。接下来我们来看一下` Observer` 的作用。

#### 		1.4 `Observer`

​		`Observer` 是一个类，它的作用是给对象的属性添加 `getter` 和 `setter`，用于依赖收集和派发更新。

​		源码目录：`src/core/observe/index.js`

```js
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 如果value是数组，对数组每一个元素执行observe方法
      this.observeArray(value)
    } else {
      // 如果value是对象， 遍历对象的每一个属性， 将属性转化为响应式属性
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  // 遍历obj的属性，将obj对象的属性转化为响应式属性
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      // 给obj的每一个属性都赋予getter/setter方法。
      // 这样一旦属性被访问或者更新，这样我们就可以追踪到这些变化
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  // 如果要观察的对象时数组， 遍历数组，然后调用observe方法将对象的属性转化为响应式属性
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}
```

​		`Observer` 中构造函数执行的逻辑：

​			(1) 实例化 `Dep` 对象；

​			(2) 通过执行 `def` 函数把自身实例添加到数据对象 `value` 的 `__ob__`属性上；

​			(3) 如果 `value` 是数组，调用 `this.observeArray(value)` 方法，`observeArray` 方法是遍历数组再次调用 `observe` 方法；

​			(4) 如果 `value` 是对象，调用 `this.walk(value)` 方法，`walk` 方法是遍历对象的 `key`  再次调用 `defineReactive` 方法；

##### 		1.4.1 `def`

​			`def` 函数是一个非常简单的 `Object.defineProperty` 的封装，这就是为什么我在开发中输出 `data` 上对象类型的数据，会发现该对象多了一个 `__ob__` 的属性。

​			源码目录：`src/core/util/lang.js`

```js
/**
 * Define a property.
 */
export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
```

#### 		1.5 `defineReactive`

​		`defineReactive` 的功能就是定义一个响应式对象，给对象动态添加 `getter` 和 `setter`。

​		源码目录：`src/core/observe/index.js`

```js
/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 每一个响应式属性都会有一个 Dep对象实例， 该对象实例会存储订阅它的Watcher对象实例
  const dep = new Dep()

  // 获取对象属性key的描述对象
  const property = Object.getOwnPropertyDescriptor(obj, key)
  // 如果属性是不可配置的，则直接返
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  // 属性原来的getter/setter
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  // 如果属性值是一个对象，递归观察属性值
  let childOb = !shallow && observe(val)
  // 重新定义对象obj的属性key
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 当obj的某个属性被访问的时候，就会调用getter方法
      const value = getter ? getter.call(obj) : val
      // 当Dep.target不为空时，调用dep.depend 和 childOb.dep.depend方法做依赖收集
      if (Dep.target) {
        // 通过dep对象， 收集依赖关系
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          // 如果访问的是一个数组， 则会遍历这个数组， 收集数组元素的依赖
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 当改变obj的属性是，就会调用setter方法。这是就会调用dep.notify方法进行通知
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      // 当响应式属性发生修改时，通过dep对象通知依赖的vue实例进行更新
      dep.notify()
    }
  })
}
```

​		`defineReactive` 执行的逻辑：

​			(1) 初始化 `Dep` 对象的实例，`const dep = new Dep()`；

​			(2) 拿到 `obj` 的属性描述符，`const property = Object.getOwnPropertyDescriptor(obj, key)`；

​			(3) 对子对象递归调用 `observe` 方法，这样就保证了无论 `obj` 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 `obj` 中一个嵌套较深的属性，也能触发 `getter` 和 `setter`；

​			(4) 调用 `Object.defineProperty` 给 `obj` 的属性 `key` 添加 `getter` 和 `setter`；

​	⚠️ 注意：响应式对象核心就是利用 `Object.defineProperty` 给数据添加了 `getter` 和 `setter`，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑: `getter` 做的事情是依赖收集，`setter` 做的事情是派发更新。

![响应式原理](https://raw.githubusercontent.com/lotosv2010/Vue-SourceCode-Analysis/master/images/06/1.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1.png)

### 2. 依赖收集

### 3. 派发更新

### 4. `nextTick`

### 5. 检测变化的注意事项

### 6. 计算属性 VS 侦听属性

### 7. 组件更新

### 8. 原理图



















