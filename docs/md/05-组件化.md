

## Vue组件化



---

[TOC]

---

​	`Vue.js` 是一个提供 `MVVM` 数据双向绑定的库，专注于 `UI` 层面，核心思想是：**数据驱动**、 **组件系统**。

​	数据驱动我们前面已经分析过了，这节主要分析组件系统。

### 1. 组件系统

 #### 	1.1 什么是[`Vue`组件](https://cn.vuejs.org/v2/guide/components.html)？

​		组件 `(Component)` 是 `Vue.js` 最强大的功能之一。组件可以扩展 `HTML` 元素，封装可重用的代码。在较高层面上，组件是自定义元素，`Vue.js` 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 `is` 特性进行了扩展的原生 `HTML` 元素。

所有的` Vue` 组件同时也都是 `Vue` 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。



#### 	1.2 组件化

​		所谓组件化，就是把⻚面拆分成多个组件 `(component)`，每个组件依 赖的 `CSS`、`JavaScript`、`模板`、`图片`等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。

​		组件的核心选项:

```markdown
(1) 模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。
(2) 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。
(3) 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。
(4) 方法（methods）：对数据的改动操作一般都在组件的方法内进行。
(5) 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。
(6) 私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。
```

​		接下来我们以下面代码为例，来分析一下 `Vue` 组件初始化的一个过程。

```js
const MyComponent = {
  // 模板
  template: '<div>{{msg}} {{privateMsg}}</div>',
  // 接受参数
  props: {
    msg: String    
  },
  // 私有数据，需要在函数中返回以避免多个实例共享一个对象
  data () {
    return {
      privateMsg: 'component!'
    }
  }
}

const App = {
  template: `<my-component :msg="msg"></my-component>`,
  components: {
    MyComponent
  },
  data() {
    return {
      msg: 'hello vue'
    }
  }
}

new Vue({
  el: '#app',
  render: createComponent => createComponent(App)
})
```

​	在分析数据驱动的章节中，我们知道 `render` 函数渲染 `VNode` 最终是调用  `_createElement` 实现的，`_createElement`函数通过传递的参数 `tag` 来判断，如果`tag`是一个普通的 html 标签，就调用 `new VNode(...)`创建 一个`ElementVNode（元素节点）` ，如果是一个组件，就调用 `createComponent` 创建一个 `ComponentVNode（组件节点）`，源码如下：

​	源码目录：`src/core/vdom/create-element.js`

```js
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n' +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

​	上面的例子中我们在 `render` 函数中传入全局组件 `APP` 创建 `VNode`对象，最终`_createElement` 调用`createComponent` 创建一个 `ComponentVNode（组件节点）`，接下来我们分析`createComponent`的源码实现。

### 2. `createComponent`

​	源码目录：`src/core/vdom/create-component.js`

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  // 获得基础构造器baseCtor
  // 这里的context是指向vm实例
  // 在'globalp-api/index.js'中，可以看到option._base指向的是Vue
  // 而在'core/instance/init.js'中，已经将全局的options与vm实例的options合并，这样baseCtor指向的就是Vue
  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    // 对组件的构造器Ctor进行扩展，实际上执行的是Vue.extend。
    // extend函数在'core/gloabal-api/extend.js'中定义
    // extend函数主要的功能是返回一个组件构造器（函数），拥有Vue相同的功能。
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  // 判断是不是函数，不是的话则抛出警告
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  // 处理组件的钩子函数
  installComponentHooks(data)

  // return a placeholder vnode
  // 注意：
  // 这个vnode中的children定义的是undefined，
  // 而在最后一个参数componentOptions中，传入了children，最后返回vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

​	通过源码我们可以清除的分析到组件渲染这个 case 主要执行以下 3 个关键步骤:

​		(1) 构造子类构造函数；

​		(2) 安装组件钩子函数；

​		(3) 实例化 vnode ；

#### 	2.1 构造子类构造函数

​		源码目录：`src/core/vdom/create-component.js`

```js
// 获得基础构造器baseCtor
// 这里的context是指向vm实例
// 在'globalp-api/index.js'中，可以看到option._base指向的是Vue
// 而在'core/instance/init.js'中，已经将全局的options与vm实例的options合并，这样baseCtor指向的就是Vue
const baseCtor = context.$options._base

// plain options object: turn it into a constructor
if (isObject(Ctor)) {
  // 对组件的构造器Ctor进行扩展，实际上执行的是Vue.extend。
  // extend函数在'core/gloabal-api/extend.js'中定义
  // extend函数主要的功能是返回一个组件构造器（函数），拥有Vue相同的功能。
  Ctor = baseCtor.extend(Ctor)
}
```

​		上面的例子，形参 `Ctor` 接受到的是一个 `App` 对象，所以调用 `baseCtor.extend(Ctor)` 函数构造子类构造函。这里的`context`是指向`vm`实例，在`globalp-api/index.js`中，可以看到`option._base`指向的是`Vue`。

​		源码目录：`src/core/globalp-api/index.js`

```js
// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue
```

​		而在`core/instance/init.js`中，已经将全局的`options`与`vm`实例的`options`合并，这样`baseCtor`指向的就是`Vue`。

​		源码目录：`src/core/instance/init.js`

```js
// 传入的options和vue自身的options进行合并
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

​		这样就把 `Vue` 上的一些 `options` 扩展到了 `vm.$option` 上， 所以我们也就能通过 `vm.$options._base`拿到 `Vue` 这个构造函数了。 `mergeOptions` 的功能是把 Vue 构造函数的 `options` 和用户传入的 `options` 做一层合并到`vm.$option`。

​		源码目录：`src/core/globalp-api/extend.js`

```js
  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    // Super指向Vue
    const Super = this
    // 指定一个SuperId
    const SuperId = Super.cid
    // 定义一个缓存构造器cachedCtors用来缓存构造器
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    // 检查组件的名字是否合法
    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name)
    }

    // 创建一个sub函数，用来继承Super（Vue）
    const Sub = function VueComponent (options) {
      this._init(options)
    }
    // 这里的继承使用的是Object.create()纯对象，即原型继承
    Sub.prototype = Object.create(Super.prototype)
    // 该函数的功能是把某个对象（对应这里的Sub.prototype）的__proto__属性关联到指定的对象
    Sub.prototype.constructor = Sub
    // 对象Sub本身扩展一些属性
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    // 对Sub的props和computed做初始化
    // 并扩展一些方法和属性
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    // 将Sub缓存起来，下次如果对应的cachedCtors中有对应的值，就直接返回，不用再创建一个组件的构造器
    cachedCtors[SuperId] = Sub
    return Sub
  }
```

​		分析源码我们可以得到结论是：`Vue.extend` 的作用就是构造一个 Vue 的子类（原型继承）。

​		`Vue.extend` 主要做了一下几件事：

​			(1) 把一个纯对象转换一个继承于 Vue 的构造器 Sub;

​			(2) 对象Sub本身扩展一些属性;

​			(3) 对Sub的props和computed做初始化;

​			(3) 将Sub缓存，避免多次执行 `Vue.extend` 的时候对同一个子组件重复构;

​		这样当我们去实例化 Sub 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑。

​		源码目录：`src/core/globalp-api/extend.js`

```js
const Sub = function VueComponent (options) {
  this._init(options)
}
```



#### 	2.2 安装组件钩子函数

​		我们之前提到 `Vue.js` 使用的 `Virtual DOM` 参考的是开源库[`snabbdom`](https://github.com/snabbdom/snabbdom)，它的一个特点是在 `VNode` 的 `patch` 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，`Vue.js` 也是充分利用这一点，在初始化一个 `Component` 类型的` VNode` 的过程中实现了几个钩子函数:

​		源码目录：`src/core/vdom/create-component.js`

```js
  // install component management hooks onto the placeholder node
  // 处理组件的钩子函数
  installComponentHooks(data)
```

​		源码目录：`src/core/vdom/create-component.js`

```js
function installComponentHooks (data: VNodeData) {
  // 获取到data中的hook
  const hooks = data.hook || (data.hook = {})
  // 循环hooksToMerge进行判断，如果data中存在该hook，则合并
  // 不存在则直接添加到data中
  // hooksToMerge定义为componentVNodeHooks的keys
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}
```

​		`installComponentHooks` 的功能是把 `componentVNodeHooks` 定义的钩子函数合并到 `data.hook`，在 VNode 执行 patch 的过程中执行相关的钩子函数。

​		这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存 在 中，那么通过执行 `mergeHook` 函数做合并，这个逻辑很简单，就是在最终执行的时 候，依次执行这两个钩子函数即可。

​		其中 `componentVNodeHooks` 定义如下：

​		源码目录：`src/core/vdom/create-component.js`

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}

const hooksToMerge = Object.keys(componentVNodeHooks)
```



#### 	2.3 实例化 `vnode`

​		源码目录：`src/core/vdom/create-component.js`

```js
// return a placeholder vnode
// 注意：
// 这个vnode中的children定义的是undefined，
// 而在最后一个参数componentOptions中，传入了children，最后返回vnode
const name = Ctor.options.name || tag
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
```

​		最后通过 `new` 一个 `VNode` 实例化一个 `vnode` 。

​		注意：这个 `vnode` 中的 `children` 定义的是`undefined`，不同与 `ElementVNode（元素节点）`的 `vnode` 。

### 3. `patch`

​		通过数据驱动的分析我们知道，当我们通过 `createComponent` 创建了组件 `VNode`，接下来会走到 `vm._update` ，执行 `vm.__patch__ ` 去把 `VNode` 转换成真正的 `DOM` 节点。这个过程我们在前一章已经分析过了，但是针对一个普通的 `VNode` 节点，接下来我们来看看组件的 `VNode` 会有哪些不一样的地方。

#### 	3.1 `createComponent`

​		`patch` 的过程会调用 `createElm` 创建元素节点。

​		源码目录：`src/core/vdom/patch.js`

```js
 function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode)
    }

    vnode.isRootInsert = !nested // for transition enter check
    // 创建组件的关键逻辑
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode) // setScope css作用域相关

      /* istanbul ignore if */
      if (__WEEX__) {
        // in Weex, the default insertion order is parent-first.
        // List items can be optimized to use children-first insertion
        // with append="tree".
        const appendAsTree = isDef(data) && isTrue(data.appendAsTree)
        if (!appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
        createChildren(vnode, children, insertedVnodeQueue)
        if (appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
      } else {
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm) // refElm参考节点
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
```

​		首先判断 `createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值，如果为 `true` 直接结束。

​		源码目录：`src/core/vdom/patch.js`

```js
 function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    let i = vnode.data // 获取到data对象
    if (isDef(i)) { // 判断data对象存在
      // 判断vode对象中存在componentInstance属性并且data对象中存在keepAlive属性
      const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
      // 判断data对象上存在钩子对象，如果存在赋值给i
      // 判断i上是否存在init方法，如果存在赋值给i
      // 两项对存在则执行init钩子
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */)
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
```

​		`createComponent` 函数中，首先对 `vnode.data ` 做了一些判断:

​			(1) 如果 vnode 是一个组件VNode，那么条件会满足；

​			(2) 得到 i 就是 init 钩子函数；

#### 	3.2 `init`

​		源码目录：`src/core/vdom/create-component.js`

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
```

​		分析源码可以知道`init` 是通过调用 `createComponentInstanceForVnode` 创建一个 Vue 的实例，然后调用 `$mount` 方法挂载子组件。

​		⚠️ 注意：暂时不考虑 `keep-alive`。

#### 	3.3 `createComponentInstanceForVnode`

​		源码目录：`src/core/vdom/create-component.js`

```js
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any, // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // check inline-template render functions
  const inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

​		从上面的源码可以看出，`createComponentInstanceForVnode` 函数构造的一个内部组件的参数，然后执行 `new vnode.componentOptions.Ctor(options)` 。这里的 `vnode.componentOptions.Ctor` 对应的就是子组件的构造函数。

​		我们上一节分析了它(`vnode.componentOptions.Ctor`)实际上是继承于 `Vue` 的一个构造器 `Sub` ，相当于 `new Sub(options)` 。

​		这里有几个关键参数要注意几个点:

​			(1) ` _isComponent` 为 `true` 表示它是一个组件;

​			(2) `_parentVnode` 表示当前激活的组件实例（注意，这里比较有意思的是如何拿到组件实例，后面会介绍）；

​		所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的 `_init` 方法，这个过程有一些和之前不同的地方需要挑出来说。

#### 	3.4 `Vue.prototype._init`

​		源码目录：`src/core/instance/init.js`

```js
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  // ...
  // a flag to avoid this being observed
  // 避免被响应式的标识
  // 这里可以暂时理解新建observer实例就是让数据响应式
  vm._isVue = true
  // merge options
  // 有子组件时，options._isComponent才会为true
  if (options && options._isComponent) { // Vue实例是组件
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
    initInternalComponent(vm, options)
  } else {
    // 传入的options和vue自身的options进行合并
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

​		这里首先是合并 `options` 的过程有变化，` _isComponent`  为 `true`，所以走到了`initInternalComponent(vm, options)`。

#### 	3.5 `initInternalComponent`

​		源码目录：`src/core/instance/init.js`

```js
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

​		这函数函数的主要逻辑有以下几点：

​			(1) `opts.parent = options.parent`;

​			(2) `opts._parentVnode = parentVnode`;

​		这两点的主要作用是把我们传递进来的参数合并到 `vm.$options`。

​		最后回到 `_init`函数中，`_init` 中 `vm.$options.el` 为false，由于组件初始化的时候是不传 `el` 的，因此组件是自己接管了`$mount` 过程。

​		回到组件 `init`的过程，`componentVNodeHooks` 的 `init` 钩子函数，在完成实例化的 `_init`后，接着会执行 `child.$mount(hydrating ? vnode.elm : undefined, hydrating)` ,相当于执行`child.$mount(undefined, false)`，它最终会调用 `mountComponent` 方法，进而执行 `vm._render()` 方法。

#### 	3.6 `Vue.prototype._render`

​		源码目录：`src/core/instance/render.js`

```js
Vue.prototype._render = function (): VNode {
    // this是Vue实例
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      // 核心方法，返回一个vnode
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      // ...
    } finally {
      currentRenderingInstance = null
    }
    // ...
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```

​		分析源码，可以得出 `_parentVnode` 就是当前组件的父 `VNode` ，而 `render` 函数生成的 `vnode` 当前组件的渲染  `vnode` 。

​		`vnode.parent = _parentVnode`从这里可以看出`vnode` 的 `parent` 指向 `_parentVnode `也就是 `vm.$vnode`(`vm.$vnode = _parentVnode`)，它们是一种父子的关系。

#### 	3.7 `Vue.prototype._update`

​		我们知道在执行完 `vm._render` 生成` VNode` 后，接下来就要执行 `vm._update` 来看一下组件渲染的过程中有哪些需要注意的。		

​		源码目录：`src/core/instance/lifecycle.js`

```js
// 保持当前上下文的 Vue 实例
export let activeInstance: any = null

Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent's updated hook.
}
```

​		`_update` 主要执行一下几个过程：

​			(1) `export let activeInstance: any = null` 中 `activeInstance` 是全局变量，作用就是保持当前上下文的 Vue 实例。并且在之前我们调用 `createComponentInstanceForVnode` 方法的时候从 `lifecycle.js ` 模块获取,并且作为参数传入的。因为实际上 `JavaScript` 是一个单线程，`Vue` 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 `Vue` 实例是什么，并把它作为子组件的父 `Vue` 实例。之前我们提到过对子组件的实例化过程先会调用 `initInternalComponent`(`Vue.prototype._init = function (options?: Object) {}`方法中)合并 `options`， 把 `parent` 存储在 `vm.$options` 中，在 `$mount` 之前会调用 `initLifecycle(vm)`方法:

​		源码目录：`src/core/instance/lifecycle.js`

```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}

```

​				可以看到 `vm.$parent` 就是用来保留当前 `vm` 的父实例，并且通过 `parent.$children.push(vm)` 来把当前的 `vm` 存储到父实例的 `$children` 中。

​			(2) `const restoreActiveInstance = setActiveInstance(vm)`:在`vm._update `的过程中，把当前的 `vm` 赋值给 `activeInstance` ，同时通过 `const prevActiveInstance = activeInstance ` 用 `prevActiveInstance` 保留上一次的 `activeInstance`。实际上，`prevActiveInstance` 和当前的 `vm` 是一个父子关系，当一个 `vm` 完成它所有子树的`patch` 或者 `update` 过程后，`activeInstance`回到它的父实例，这样就完 美地保证了`createComponentInstanceForVnode` 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 `Vue` 实例，并在 `_init` 的过程中，通过 `vm.$parent` 把这个父子关系保留。

​		源码目录：`src/core/instance/lifecycle.js`

```js
export function setActiveInstance(vm: Component) {
  const prevActiveInstance = activeInstance
  activeInstance = vm
  return () => {
    activeInstance = prevActiveInstance
  }
}
```

​			(3) `vm._vnode = vnode`, `vnode` 是通过 `vm._render()` 返回的组件渲染 `VNode`，`vm._vnode` 和 `vm.$vnode`关系是一种父子关系，即 `vm._vnode.parent === vm.$vnode`。

​			(4) `__patch__`: `vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)`

​		源码目录：`src/core/vdom/patch.js`

```js
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    // ...
    let isInitialPatch = false
    const insertedVnodeQueue = []
    
    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // ...
    }
    // ...
  }

```

​				这里又回到了本节开始的过程，之前分析过负责渲染成 `DOM` 的函数是 `createElm` ，注意这里我们只 传了 2 个参数，所以对应的 `parentElm` 是 `undefined` 。我们再来看看它的定义:

​		源码目录：`src/core/vdom/patch.js`

```js
 function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    // ...
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      // ...

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode) // setScope css作用域相关

      /* istanbul ignore if */
      if (__WEEX__) {
        // ...
      } else {
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm) // refElm参考节点
      }

      // ...
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
```

​			注意，这里我们传入的 `vnode` 是组件渲染的 `vnode` ，也就是我们之前说的 `vm._vnode`，如果组件的根节点是个普通元素，那么 `vm._vnode` 也是普通的 `vnode` ，这里`createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值是 `false`。接下来的过程就和我们上一章一样 了，先创建一个父节点占位符，然后再遍历所有子 `VNode` 递归调用 `createElm` ，在遍历的过程中，如果遇到子` VNode` 是一个组件的 `VNode`，则重复本节开始的过程，这样通过一个递归的方式就可以完 整地构建了整个组件树。

​			由于我们这个时候传入的 `parentElm` 是空，所以对组件的插入，在` createComponent` 有这么一段逻辑:

​		源码目录：`src/core/vdom/patch.js`

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    let i = vnode.data // 获取到data对象
    if (isDef(i)) { // 判断data对象存在
      // ...
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */)
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
```

​			在完成组件的整个过程后，最后执行` insert(parentElm, vnode.elm, refElm)` 完成组件的 `DOM` 插入，如果组件过程中又创建了子组件，那么`DOM` 的插入顺序是先子后父。

### 4.  合并配置

​	通过之前的源码分析我们知道， new Vue 的过程通常有 2 种场景：

​		(1) 外部开发者调用 `new Vue({...})` 的方式实例化一个 `Vue` 对象;

​		(2) 组件实例化过程中，内部通过  `new vnode.componentOptions.Ctor(options)` 实例化子组件时调用。

​	我们以下面的例子来分析合并配置的源码：

```js
const ChildComp = {
  // 模板
  template: '<div>{{msg}}</div>',
  created() {
    console.log('child created')
  },
  mounted() {
    console.log('child mounted')
  },
  // 私有数据，需要在函数中返回以避免多个实例共享一个对象
  data () {
    return {
      msg: 'merge option!'
    }
  }
}

Vue.mixin({
  created() {
    console.log('parent created')
  }
})

new Vue({
  el: '#app',
  render: h => h(ChildComp)
})
```

​	源码目录：`src/core/instance/init.js`

```js
Vue.prototype._init = function (options?: Object) {
    // ...
    // merge options
    // 有子组件时，options._isComponent才会为true
    if (options && options._isComponent) { // Vue实例是组件
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
      initInternalComponent(vm, options)
    } else {
      // 传入的options和vue自身的options进行合并
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
  	// ...
  }
```

#### 	4.1 `new Vue`

​		这种情景下当开发者调用 `new Vue(options)` 创建一个 `Vue` 实例时，执行的是下面的逻辑：

​		源码目录：`src/core/instance/init.js`

```js
 // 传入的options和vue自身的options进行合并
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

​		从上面的源码可以看出，通过调用 `mergeOptions` 对传入的 `options` 和 `vue` 自身的`options` 进行合并，其中 `resolveConstructorOptions(vm.constructor)` 在当前场景下的返回值还是 `vm.constructor.options` ，相当于 `Vue.options` ，那么这个值又是什么呢，其实在  `src/core/index.js` 中调用 `initGlobalAPI(Vue)`  的时候定义了这个值。

##### 		4.1.1 initGlobalAPI

​			源码目录：`src/core/global-api/index.js`

```js

export function initGlobalAPI (Vue: GlobalAPI) {
  // ...
  
  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)

  // ...
}
```

​		上面代码主要执行了一下几个过程：

​			(1) 调用 `Object.create(null)` 创建一个空的对象，并赋值给 `Vue.options`；

​			(2) 遍历 `ASSET_TYPES` 给 `Vue.options` 上新增 `ASSET_TYPES` 中 `每一项 + s` 这样的属性；其中 `ASSET_TYPES` 的源码如下：

​			源码目录：`src/shared/constants.js`

```js
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
```

​			便利后即给`Vue.options` 添加一下属性：

```
Vue.options.components = Object.create(null)
Vue.options.directives = Object.create(null)
Vue.options.filters = Object.create(null)
```

​			(3)  `Vue.options._base = Vue`： `option._base`指向的是`Vue`；

​			(4)  `extend(Vue.options.components, builtInComponents)` ：把一些内置组件扩展到 `Vue.options.components` 上，Vue 的内置组件目前有 `KeepAlive` 、`Transition`、`TransitionGroup`，这也就是为什么我们在其它组件中使用这三个组件不需要注册的原因。

##### 		4.1.2 `mergeOptions ` 

​		源码目录：`src/core/util/options.js`

```js
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

​			`mergeOptions` 主要功能就是把 `parent` 和 `child` 这两个对象根据一些合并策略，合并成一个新 对象并返回。主要有以下几点核心逻辑：

​				(1) 递归把 `extends`和 `mixixns` 合并到 `parent` 上 ;

​				(2) 遍历`parent`，调用 `mergeField` ;

​				(3) 遍历 `child`如果  `key` 不在 `parent` 的自身属性上，调用 `mergeField` ;

##### 		4.1.3 `mergeField ` 

​			源码目录：`src/core/util/options.js`

```js
const strats = config.optionMergeStrategies

function mergeField (key) {
  const strat = strats[key] || defaultStrat
  options[key] = strat(parent[key], child[key], vm, key)
}
```

​			`mergeField` 函数，它对不同的` key` 有着不同的合并策略，对于生命周期函数，它的合并策略是这样的:

​		源码目录：`src/core/util/options.js`

```js

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> {
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  const res = []
  for (let i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i])
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})
```

​		这其中的 `LIFECYCLE_HOOKS` 的定义如下:

​		源码目录：`src/shared/constants.js`

```js
export const LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
]
```

​		这里定义了 `Vue.js` 所有的钩子函数名称，所以对于钩子函数，他们的合并策略都是 `mergeHook` 函数。这个函数的实现也非常有意思，用了一个多层 3 元运算符，逻辑就是如果不存在 `childVal`，就返回`parentVal` ;否则再判断是否存在`parentVal`，如果存在就把`childVal`添加到`parentVal`后返回新数组;否则返回`childVal`。

​		所以回到`mergeHook`函数，一旦`parent` 和 `child` 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。

​		关于其它属性的合并策略的定义都可以在 `src/core/util/options.js` 文件中看到。

​		通过执行 `mergeField` 函数，把合并后的结果保存到 `options` 对象中，最终返回它。

​		因此，在我们当前这个 case 下，执行完如下合并后:

​		源码目录：`src/core/instance/init.js`

```js
// 传入的options和vue自身的options进行合并
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

​		`vm.$options` 的值差不多是如下这样:

```js
vm.$options = { 
  components: { }, 
  created: [
		function created() { 
      console.log('parent created')
    }
  ],
	directives: { },
	filters: { },
	_base: function Vue(options) {
		// ...
  },
  el: "#app",
  render: function (h) {
		//...
	}
}
```



#### 	4.2 `new Sub` 

​		组件的构造函数是通过 `Vue.extend` 继承自 `Vue` 的（`src/core/vdom/create-component.js` 中 `createComponent` 函数中调用 `Ctor = baseCtor.extend(Ctor)`）。

​		源码目录：`src/core/global-api/extend.js`

```js
/**
   * Class inheritance
   */
Vue.extend = function (extendOptions: Object): Function {
  // ...
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  )
  
  // ...

  // keep a reference to the super options at extension time.
  // later at instantiation we can check if Super's options have
  // been updated.
  Sub.superOptions = Super.options
  Sub.extendOptions = extendOptions
  Sub.sealedOptions = extend({}, Sub.options)

  // cache constructor
  // 将Sub缓存起来，下次如果对应的cachedCtors中有对应的值，就直接返回，不用再创建一个组件的构造器
  cachedCtors[SuperId] = Sub
  return Sub
}
```

​		我们只保留关键逻辑，这里的 `extendOptions ` 对应的就是前面定义的组件对象， 它会和 `Vue.options` 合并到`Sub.options`中。

​		接下来我们再回忆一下子组件的初始化过程。

​		源码目录：`src/core/vdom/create-component.js` 

```js
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any, // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // ...
  return new vnode.componentOptions.Ctor(options)
}
```

​		这里的 `vnode.componentOptions.Ctor` 就是指向 `Vue.extend` 的返回值 `Sub`， 所以执行 `new vnode.componentOptions.Ctor(options)` 就相当于是执行 `new Sub(options)`。

​		源码目录：`src/core/global-api/extend.js`

```js
// 创建一个sub函数，用来继承Super（Vue）
var Sub = function VueComponent (options) {
  this._init(options);
};
```

​		源码目录：`src/core/instance/init.js` 

```js
Vue.prototype._init = function (options?: Object) {
  // ...
  // merge options
  // 有子组件时，options._isComponent才会为true
  if (options && options._isComponent) { // Vue实例是组件
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
    initInternalComponent(vm, options)
  } else {
    // ...
  }
  // ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```
​		执行 `new Sub(options)` ，接着就是执行 `this._init(options)`，因为 `options._isComponent` 为 `true`，合并代码的逻辑会执行 `if` 语句 `initInternalComponent(vm, options)`。

​		源码目录：`src/core/instance/init.js` 

```js
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

​		`initInternalComponent` 方法首先执行 `const opts = vm.$options = Object.create(vm.constructor.options)`，这里的 `vm.constructor `就是子组件的构造函数 `Sub `相当于 `vm.$options =Sub.options `。

​		接着又把实例化子组件传入的子组件父 `VNode` 实例 `parentVnode`、子组件的父 `Vue` 实例 `parent`，保存到 `vm.$options` 中，另外还保留了 `parentVnode` 配置中的如 `propsData` 等其他属性。

​		`initInternalComponent` 只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。

​		因此，在我们当前这个 case 下，执行完如下合并后:

​		源码目录：`src/core/instance/init.js` 

```js
// optimize internal component instantiation
// since dynamic options merging is pretty slow, and none of the
// internal component options needs special treatment.
/*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
initInternalComponent(vm, options)
```

​		`vm.$options` 的值差不多是如下这样:

```js
vm.$options = {
	parent: Vue /*父Vue实例*/, 
  propsData: undefined, 
  _componentTag: undefined, 
  _parentVnode: VNode /*父VNode实例*/, 
  _renderChildren:undefined, 
  __proto__: {
    components: { },
		directives: { },
		filters: { },
		_base: function Vue(options) {
			//...
    },
    _Ctor: {},
    created: [
			function created() {
        console.log('parent created')
			}, 
      function created() { 
        console.log('child created')
			}
    ],
    mounted: [
      function mounted() {
				console.log('child mounted') 
      }
		], 
    data() {
       return {
         msg: 'Hello Vue'
       }
    },
    template: '<div>{{msg}}</div>'
  }
}
```

​		那么至此，`Vue` 初始化阶段对于 `options` 的合并过程就介绍完了，我们需要知道对于 `options` 的 合并有 2 种方式，子组件初始化过程通过 `initInternalComponent(vm, options)` 方式要比外部初始化 `Vue` 通过 `mergeOptions` 的 过程要快，合并完的结果保留在`vm.$options`中。

### 5. 生命周期

​		每个 Vue 实例在被创建时都要经过一系列的初始化过程，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做[**生命周期钩子**]([https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期钩子))的函数，这给了用户在不同阶段添加自己的代码的机会。

​	![生命周期](https://cn.vuejs.org/images/lifecycle.png)

​	

 源码目录：`src/core/instance/lifecycle.js` 

```js

export function callHook (vm: Component, hook: string) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

​		`callHook`  函数的逻辑很简单，根据传入的字符串 `hook` ，去拿到 `vm.$options[hook]` 对应的回调函数数组，然后遍历执行，执行的时候把` vm` 作为函数执行的上下文。

​		` Vue.js`  合并 `options` 的过程，各个阶段的生命周期的函数也被合并到 `vm.$options` 里，并且是一个数组。因此 `callHook` 函数的功能就是调用某个生命周期钩子注册的所有回调函数。

​		了解了生命周期的执行方式后，接下来我们会具体介绍每一个生命周期函数它的调用时机。

#### 	5.1 `beforeCreate & created`

​	`beforeCreate ` 和 `created` 函数都是在实例化 `Vue` 的阶段，在` _init` 方法中执行的。

​	源码目录：`src/core/instance/init.js` 

```js
 Vue.prototype._init = function (options?: Object) {
    // ...
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    // ...
  }
```

​		从上面代码可以看出`beforeCreate ` 和 `created`  分别在 `initState(vm)` 前后调用的， `initState(vm)`  主要的作用是初始化 `props`、`data`、`methods`、`watch`、`computed` 等属性。因此 `beforeCreate ` 钩子函数中不能获取 `props`、`data` 定义的值，也不能调用`methods` 中定义的函数。

​		在这俩个钩子函数执行的时候，并没有渲染 `DOM`，所以我们也不能够访问 `DOM`，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问`props`、`data` 等数据的话，就需要使用`created` 钩子函数。

 		在 `vue-router` 和 `vuex` 中它们都混合了`beforeCreate ` 钩子函数。

#### 	5.2 `beforeMount & mounted`

​		`beforeMount` 钩子函数发生在 `mount`，也就是` DOM` 挂载之前，它的调用时机是在 `mountComponent` 函数中。

​		源码目录：`src/core/instance/lifecycle.js` 

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  // 调用生命周期钩子beforeMount
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    // ...
  } else {
    updateComponent = () => {
      // 首先vm._update和vm._render这两个方法是定义在Vue原型上的
      // 1.vm._render()把实例渲染成一个虚拟 Node
      // 2.vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // 调用生命周期钩子mounted
    callHook(vm, 'mounted')
  }
  return vm
}
```

​		在执行 `vm._render()` 函数渲染 VNode 之前，执行了 `beforeMount` 钩子函数，在执行完 `vm._update()` 把 `VNode patch` 到真实 `DOM` 后，执行 `mounted` 钩子函数。

​		⚠️ 注意，这里对 `mouted` 钩子函数执行有一个判断逻辑，`vm.$vnode` 如果为 `null` 表明这不是一次组件的初始化过程，而是开发者通过 `new Vue()` 初始的过程。

​		组件的 `VNode patch` 到 `DOM` 后，会执行 `invokeInsertHook` 函数，把 `insertedVnodeQueue` 里保存的钩子函数依次执行一遍。

​		源码目录：`src/core/vdom/patch.js` 

```js
  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue
    } else {
      for (let i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i])
      }
    }
  }
```

​		该函数会执行 `insert` 这个钩子函数，对于组件而言，`insert` 钩子函数的定义在 `componentVNodeHooks`。

 		源码目录：`src/core/vdom/create-component.js` 

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    // ...
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    // ...
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    // ...
  },

  destroy (vnode: MountedComponentVNode) {
    //...
  }
}

```

​		我们可以看到，每个子组件都是在这个钩子函数中执行 `mouted` 钩子函数，并且我们之前分析过， `insertedVnodeQueue`  的添加顺序是先子后父，所以对于同步渲染的子组件而言， `mounted` 钩子函数的执行顺序也是先子后父。

#### 	5.3 `beforeUpdate & updated`

​		`beforeUpdate` 和 `updated` 的钩子函数执行时机都应该是在数据更新的时候。

​		`beforeUpdate` 的执行时机是在渲染` Watcher` 的 `before` 函数中。

​		源码目录：`src/core/instance/lifecycle.js` 

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  // ...
  return vm
}
```

​		⚠️ 注意：这里有个判断，也就是在组件已经 `mounted` 之后，才会去调用这个钩子函数。

​		`update` 的执行时机是在 `flushSchedulerQueue` 函数调用的时候。

​		源码目录：`src/core/observer/scheduler.js` 

```js

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  // ...
  
  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)
  
  // ...
}

function callUpdatedHooks (queue) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}
```

​		`updatedQueue` 是更新了的 `watcher` 数组，那么在 `callUpdatedHooks (queue)` 函数中，它对这些数组做遍历，只有满足当前 `watcher` 为 `vm._watcher` 以及组件已经 `mounted` 这两个条件，才会执行 `update` 钩子函数。

​		在组件 `mount` 的过程中，会实例化一个渲染的 `Watcher` 去监听 `vm` 上的数据变化重新渲染，这段逻辑发生在 `mountComponent` 函数执行的时候:

​		源码目录：`src/core/instance/lifecycle.js` 

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  // ...
  return vm
}
```

​		在实例化 `Watcher` 的过程中，在它的构造函数里会判断 `isRenderWatcher` 接着把当前 `watcher` 的实例赋值给 `vm._watcher` 。

，接着把当前 中:

​		源码目录：`src/core/observer/watcher.js` 

```js
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
  // ...

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)

    // ...
  }
}

```

​		同时，还把当前 `wathcer` 实例 `push` 到 `vm._watchers`  中，`vm._watchers` 是专门用来监听 `vm` 上数据变化然后重新渲染的，所以它是一个渲染相关的 `wathcer` 因此在`callUpdatedHooks (queue)` 函数中，只有 `vm._watchers` 的回调执行完毕后，才会执行 `update` 钩子函数

#### 	5.4 `beforeDestroy & destroyed`

​		`beforeDestroy`  和 `destroyed` 钩子函数的执行时机在组件销毁的阶段，最终会调用 `$destroy` 方法。

​		源码目录：`src/core/instance/lifecycle.js` 

```js

export function lifecycleMixin (Vue: Class<Component>) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    // ...
  }

  Vue.prototype.$forceUpdate = function () {
    // ...
  }

  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}

```

​		`beforeDestroy`  钩子函数的执行时机是在 `$destroy` 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 `parent` 和 `$children ` 中删掉自身，删除 `watcher`，当前渲染的 `VNode` 执行销毁钩子函数等，执行完毕后再调用 `destroyed` 钩子函数。 

​		在 `$destroy` 的执行过程中，它又会执行 `vm.__patch__(vm._vnode, null)`触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 `destroyed` 钩子函数执行顺序是先子后父，和 `mounted` 程一样。

#### 	5.5 `activated & deactivated`

​		`activated` 和 `deactivated`钩子函数是专门为 `keep-alive` 组件定制的钩子，后面分析 `keep-alive` 的时候在做详细分析

### 6.  组件注册

​	`vue.js` 的内置组件主要有 `keep-alive` 、 `component` 、 `transition` 、 `transition- group`等，除了内置组件，`vue.js` 也提供[组件注册](https://cn.vuejs.org/v2/guide/components-registration.html)的接口，主要有全局注册和局部注册2种。

#### 	6.1 全局注册

​		`vue.js` 全局组件，可以使用 `Vue.component(tagName, options)` ，如下代码:

```js
Vue.component(`HelloVue`, {
  // 配置项
})
```

​		 `Vue.component(tagName, options)`函数是在什么时候定义的呢，它的定义过程发生在最开始初始化 Vue 的全局 函数的时候。

​		源码目录：`src/core/global-api/assets.js` 

```js
/* @flow */

import { ASSET_TYPES } from 'shared/constants'
import { isPlainObject, validateComponentName } from '../util/index'

export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```

​		`initAssetRegisters` 函数首先遍历 `ASSET_TYPES`，得到 `type` 后挂载到 `Vue` 上 。

​		源码目录：`src/shared/constants.js`

```js
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
```

​		所以实际上 `Vue `是初始化了 3 个全局函数，并且如果 `type` 是 `component `且 `definition`   一个对象的话，通过 `this.options._base.extend` ， 相当于 `Vue.extend` 把这个对象转换成一个继承于 `Vue `的构造函数，最后通过 `this.options[type + 's'][id] = definition` 把它挂载到 `this.options.components`上。

​		由于我们每个组件的创建都是通过 `Vue.extend` 继承而来，我们之前分析过在继承的过程中有这么一段逻辑:

​		源码目录：`src/core/global-api/extend.js` 

```js
Sub.options = mergeOptions(
  Super.options,
  extendOptions
)
```

​		从这段代码，可以看`Vue.extend` 把 `Vue.options` 合并到 `Sub.options`，也就是组件的 `options` 上，然后在组件的实例化阶段，会执行 `merge options` 逻辑，把 `Sub.options.components ` 合并到 `vm.$options.components` 上。

​		然后在创建 `vnode` 的过程中，会执行 `_createElement` 方法。

​		源码目录：`src/core/vdom/create-element`.js` 

```js
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  // ...
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  // ...
}
```

​		`isDef(Ctor = resolveAsset(context.$options, 'components', tag))`。

​		源码目录：`src/core/util/options.js` 

```js
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
export function resolveAsset (
  options: Object,
  type: string,
  id: string,
  warnMissing?: boolean
): any {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // check local registration variations first
  if (hasOwn(assets, id)) return assets[id]
  const camelizedId = camelize(id)
  if (hasOwn(assets, camelizedId)) return assets[camelizedId]
  const PascalCaseId = capitalize(camelizedId)
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
  // fallback to prototype chain
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}
```

​		这段代码主要执行了以下逻辑

​			(1) 通过 `const assets = options[type]` 拿到 `assets` ；

​			(2)  直接使用 `id` 拿 `assets[id]`；

​			(3) 如果 `assets[id]` 不存在，则把 id 变成驼峰的形式再拿；

​			(4)  如果`assets[camelizedId]`不存在则在驼峰的基础上把首字母再变成大写的形式再拿；

​			(4) 如果仍然拿不到则报错。

​		这样说明了我们在使用 `Vue.component(id, definition)` 全局注册组件的时候，`id` 可以是连字符、驼峰或首字母大写的形式。

​		`resolveAsset(context.$options, 'components', tag)` 即拿 `vm.$options.components[tag]`，这样我们就可以在 `resolveAsset` 的时候拿到这个组件的构造函数，并作为 `createComponent` 的钩子的参数。

#### 	6.2 局部注册

​		`vue.js` 局部注册组件，可以使用 `components: {}`属性 ，如下代码:

```js
import HelloWorld from './components/HelloWorld'
export default {
  components: {
		HelloWorld 
  }
}
```

​		在组件的 `Vue` 的实例化阶段有一个合并 `option` 的逻辑，之前我们也分析过，所以就把 ` components` 合并到 `vm.$options.components` 上，这样我们就可以在 `resolveAsset` 的时候拿到这个组件的构造函数，并作为 `createComponent` 的钩子的参数。

​		注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 `Vue.options` 下，所以在所有组件创建的过程中，都会从全局的 `Vue.options.components` 扩展到当前组件的 `Vm.$options.components` 下，这就是全局注册的组件能被任意使用的原因。

### 7. 异步组件

​		在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成[异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)，按需加载。`Vue` 也原生支持了异步组件的能力，如下：

```js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})
```

​		示例中可以看到，`Vue` 注册的组件不再是一个对象，而是一个工厂函数，函数有两个参数 `resolve` 和 `reject `，函数内部用 `setTimeout` 模拟了异步，实际使用可能是通过动态请求异步组件的 `JS` 地址，最终通过执行 `resolve` 方法，它的参数就是我们的异步组件对象。

​		在了解了异步组件如何注册后，我们从源码的角度来分析一下它的实现。

​		上一节我们分析了组件的注册逻辑，由于组件的定义并不是一个普通对象，所以不会执行 `Vue.extend `的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 `createComponent` 函数，我们再来对这个函数做回顾。

​		源码目录：`src/core/vdom/create-component.js` 

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  // 获得基础构造器baseCtor
  // 这里的context是指向vm实例
  // 在'globalp-api/index.js'中，可以看到option._base指向的是Vue
  // 而在'core/instance/init.js'中，已经将全局的options与vm实例的options合并，这样baseCtor指向的就是Vue
  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    // 对组件的构造器Ctor进行扩展，实际上执行的是Vue.extend。
    // extend函数在'core/gloabal-api/extend.js'中定义
    // extend函数主要的功能是返回一个组件构造器（函数），拥有Vue相同的功能。
    Ctor = baseCtor.extend(Ctor)
  }

  // ...

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  // ...

  return vnode
}
```

​		我们省略了不必要的逻辑，只保留关键逻辑，由于我们这个时候传入的` Ctor` 是一个函数，那么它也并不会执行 `Vue.extend` 逻辑，因此它的 `cid` 是 `undefiend`，进入了异步组件创建的逻辑。

​		接着执行 `resolveAsyncComponent(asyncFactory, baseCtor)` 方法。

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  const owner = currentRenderingInstance
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner)
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    const owners = factory.owners = [owner]
    let sync = true
    let timerLoading = null
    let timerTimeout = null

    ;(owner: any).$on('hook:destroyed', () => remove(owners, owner))

    const forceRender = (renderCompleted: boolean) => {
      for (let i = 0, l = owners.length; i < l; i++) {
        (owners[i]: any).$forceUpdate()
      }

      if (renderCompleted) {
        owners.length = 0
        if (timerLoading !== null) {
          clearTimeout(timerLoading)
          timerLoading = null
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout)
          timerTimeout = null
        }
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true)
      } else {
        owners.length = 0
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender(true)
      }
    })

    const res = factory(resolve, reject)

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            timerLoading = setTimeout(() => {
              timerLoading = null
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender(false)
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(() => {
            timerTimeout = null
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

​		`resolveAsyncComponent` 函数的逻辑略复杂，因为它实际上处理了 3 种异步组件的创建方式，如下：

​		方式一：

```js
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})
```



​		方式二：

```js
Vue.component(
  'async-webpack-example',
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () => import('./my-async-component')
)
// 或
new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
```



​		方式三：

```js
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
```



#### 	7.1 普通函数异步组件

​		针对普通函数的情况，前面几个 `if` 判断可以忽略，它们是为高级组件所用，对于 `factory.contexts` 的判断，是考虑到多个地方同时初始化一个异步组件，那么它的实际加载应该只有一次。接着进入实际加载逻辑，定义 `forceRender` 、`resolve` 和 `reject` 函数。

​		注意 `resolve` 和 `reject` 函数用 `once` 函数做了一层包装。

​		源码目录：`src/shared/util.js`

```js
/**
 * Ensure a function is called only once.
 */
export function once (fn: Function): Function {
  let called = false
  return function () {
    if (!called) {
      called = true
      fn.apply(this, arguments)
    }
  }
}
```

​		`once` 逻辑非常简单，传入一个函数，并返回一个新函数，它非常巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次，也就是确保 `resolve` 和` reject` 函数只执行一次。

​		接下来执行 `factory.resolved = ensureCtor(res, baseCtor)` 逻辑，这里就相当于执行我们组件的工厂函数，同时把 `resolve` 和` reject` 函数作为参数传入，组件的工厂函数通常会先发送请求去加载异步组件的 `js` 文件，拿到组件定义的对象 `res` 后，执行 `resolve(res)` 逻辑，他会先执行 `factory.resolved = ensureCtor(res, baseCtor)`。

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
function ensureCtor (comp: any, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}
```

​		这个函数目的是为了保证能找到异步组件 `JS` 定义的组件对象，并且如果它是一个普通对象，则调用 `Vue.extend` 把它转换成一个组件的构造函数。

​		`resolve` 逻辑最后判断了 `sync`，显然我们这个场景下 `sync` 为 `false`，那么就会执行 `forceRender` 函数，它会遍历 `factory.contexts`，拿下每一个调用异步组件的实例 `vm`，执行 `vm.$forceUpdate()` 方法。

​		 源码目录：`src/core/instance/lifecycle.js`

```js
 Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }
```

​		`$forceUpdate` 的逻辑非常简单，就是调用渲染 `watcher` 的 `update` 方法，让渲染 `watcher` 对应的回调函数执行，也就是触发了组件的重新渲染。之所以这么做是因为` Vue` 通常是数据驱动视图重 新渲染，但是在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 `$forceUpdate` 可以强制组件重新渲染一次。

#### 	7.2 `Promise` 异步组件

```js
Vue.component(
  'async-webpack-example',
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () => import('./my-async-component')
) 
```

​		`webpack 2+` 支持了异步加载的语法糖: `() => import('./my-async-component')` ，当执行完 `res = factory(resolve, reject)` ，返回的值就是 `import('./my-async-component')`  的返回值，它是一个 `Promise` 对象。接着进入`if` 条件，有判断了 `typeof res.then === 'function'`，条件满足，执行：

```js
if (isUndef(factory.resolved)) { 
  res.then(resolve, reject)
}
```

​		当组件异步加载成功后，执行 `resolve` ，加载失败则执行` reject `，这样就非常巧妙地实现了配合 `webpack 2+` 的异步加载组件的方式`(Promise)`加载异步组件。

#### 	7.3 高级异步组件

​		由于异步加载组件需要动态加载 `JS`，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计` loading` 组件和` error` 组件，并在适当的时机渲染它们。`Vue.js 2.3+` 支 持了一种高级异步组件的方式，它通过一个简单的对象配置，帮你搞定 `loading` 组件和 `error` 组件的渲染时机，你完全不用关心细节，非常方便。接下来我们就从源码的角度来分析高级异步组件是怎么实现的。

```js
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
```

​		高级异步组件的初始化逻辑和普通异步组件一样，也是执行 `resolveAsyncComponent`，当执行完 `res = factory(resolve, reject)`，返回值就是定义的组件对象，显然满足 `else if (isDef(res.component) && typeof res.component.then === 'function')` 的逻辑，接着执行 `res.component.then(resolve, reject)`，当异步组件加载成功后，执行 `resolve` ，失败执行 `reject`。

​		因为异步组件加载是一个异步过程，它接着又同步执行了如下逻辑:

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
if (isDef(res.error)) {
  factory.errorComp = ensureCtor(res.error, baseCtor)
}

if (isDef(res.loading)) {
  factory.loadingComp = ensureCtor(res.loading, baseCtor)
  if (res.delay === 0) {
    factory.loading = true
  } else {
    timerLoading = setTimeout(() => {
      timerLoading = null
      if (isUndef(factory.resolved) && isUndef(factory.error)) {
        factory.loading = true
        forceRender(false)
      }
    }, res.delay || 200)
  }
}

if (isDef(res.timeout)) {
  timerTimeout = setTimeout(() => {
    timerTimeout = null
    if (isUndef(factory.resolved)) {
      reject(
        process.env.NODE_ENV !== 'production'
        ? `timeout (${res.timeout}ms)`
        : null
      )
    }
  }, res.timeout)
}
```

​		先判断 `res.error` 是否定义了 `error` 组件，如果有的话则赋值给 `factory.errorComp`。接着判断 `res.loading`是否定义了 `loading`组件，如果有的话则赋值给 `factory.loadingComp`，如果设置了 `res.delay` 且为0，则设置 `factory.loading = true`，否则延时 `delay` 的时间执行：

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
if (isUndef(factory.resolved) && isUndef(factory.error)) {
  factory.loading = true
  forceRender(false)
}
```

​		最后判断 `res.timeout`，如果配置了该项，则在 `res.timout` 时间后，如果组件没有成功加载，执行 `reject`。

​		在 `resolveAsyncComponen`t 的最后有一段逻辑:

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
sync = false
// return in case resolved synchronously
return factory.loading
  ? factory.loadingComp
: factory.resolved
```

​		如果 `delay` 配置为 `0`，则这次直接渲染` loading` 组件，否则则延时 `delay` 执行 `forceRender` ，那么又会再一次执行到 `resolveAsyncComponent` 。

​		那么这时候我们有几种情况，按逻辑的执行顺序，对不同的情况做判断。

##### 	7.3.1 异步组件加载失败

​		当异步组件加载失败，会执行` reject` 函数:

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
const reject = once(reason => {
  process.env.NODE_ENV !== 'production' && warn(
    `Failed to resolve async component: ${String(factory)}` +
    (reason ? `\nReason: ${reason}` : '')
  )
  if (isDef(factory.errorComp)) {
    factory.error = true
    forceRender(true)
  }
})
```

​		这个时候会把 `factory.error` 设置为 true ，同时执行 `forceRender()` 再次执行到 `resolveAsyncComponent` :

```js
 if (isTrue(factory.error) && isDef(factory.errorComp)) { 
   return factory.errorComp
 }
```

​		那么这个时候就返回 `factory.errorComp` ，直接渲染 `error` 组件。

##### 	7.3.2 异步组件加载成功

​		当异步组件加载成功，会执行 `resolve` 函数:

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
    const resolve = once((res: Object | Class<Component>) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true)
      } else {
        owners.length = 0
      }
    })
```

​		首先把加载结果缓存到 `factory.resolved` 中，这个时候因为 `sync` 已经为 `false`，则执行` forceRender()` 再次执行到 `resolveAsyncComponent`:

```js
if (isDef(factory.resolved)) { 
	return factory.resolved
}
```

​		那么这个时候直接返回 `factory.resolved` ，渲染成功加载的组件。

##### 	7.3.3 异步组件加载中

​		如果异步组件加载中并未返回，这时候会走到这个逻辑:

```js
if (isTrue(factory.loading) && isDef(factory.loadingComp)) { 
	return factory.loadingComp
}
```

​		那么则会返回 `factory.loadingComp` ，渲染` loading` 组件。

##### 	7.3.4 异步组件加载超时

​		如果超时，则走到了 `reject` 逻辑，之后逻辑和加载失败一样，渲染 `error` 组件。

##### 	7.3.5 异步组件`patch`

​		回到 `createComponent` 的逻辑:

​		源码目录：`src/core/vdom/create-component.js`

```js
  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
```

​		如果是第一次执行 `resolveAsyncComponent` ，除非使用高级异步组件 `0 delay` 去创建了一个 `loading` 组件，否则返回是 `undefined`，接着通过 `createAsyncPlaceholder` 创建一个注释节点作为占位符。

​		源码目录：`src/core/vdom/helpers/resolve-async-component.js` 

```js
export function createAsyncPlaceholder (
  factory: Function,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag: ?string
): VNode {
  const node = createEmptyVNode()
  node.asyncFactory = factory
  node.asyncMeta = { data, context, children, tag }
  return node
}
```

​		实际上就是就是创建了一个占位的注释 `VNode`，同时把 `asyncFactory` 和 `asyncMeta` 赋值给当前 `vnode` 。

​		当执行 `forceRender` 的时候，会触发组件的重新渲染，那么会再一次执行 `resolveAsyncComponent`，这时候就会根据不同的情况，可能返回 `loading` 、`error`或成功加载的异步组件，返回值不为 `undefined`，因此就走正常的组件`render`、`patch`过程，与组件第一次渲染流程不一样，这个时候是存在新旧 `vnode` 的。







