

## Vue组件化



---

[TOC]

---

​	`Vue.js` 是一个提供 `MVVM` 数据双向绑定的库，专注于 `UI` 层面，核心思想是：**数据驱动**、 **组件系统**。

​	数据驱动我们前面已经分析过了，这节主要分析组件系统。

### 1. 组件系统

 #### 	1.1 什么是[`Vue`组件](https://cn.vuejs.org/v2/guide/components.html)？

​		组件 `(Component)` 是 `Vue.js` 最强大的功能之一。组件可以扩展 `HTML` 元素，封装可重用的代码。在较高层面上，组件是自定义元素，`Vue.js` 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 `is` 特性进行了扩展的原生 `HTML` 元素。

所有的` Vue` 组件同时也都是 `Vue` 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。



#### 	1.2 组件化

​		所谓组件化，就是把⻚面拆分成多个组件 `(component)`，每个组件依 赖的 `CSS`、`JavaScript`、`模板`、`图片`等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。

​		组件的核心选项:

```markdown
(1) 模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。
(2) 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。
(3) 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。
(4) 方法（methods）：对数据的改动操作一般都在组件的方法内进行。
(5) 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。
(6) 私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。
```

​		接下来我们以下面代码为例，来分析一下 `Vue` 组件初始化的一个过程。

```js
const MyComponent = {
  // 模板
  template: '<div>{{msg}} {{privateMsg}}</div>',
  // 接受参数
  props: {
    msg: String    
  },
  // 私有数据，需要在函数中返回以避免多个实例共享一个对象
  data () {
    return {
      privateMsg: 'component!'
    }
  }
}

const App = {
  template: `<my-component :msg="msg"></my-component>`,
  components: {
    MyComponent
  },
  data() {
    return {
      msg: 'hello vue'
    }
  }
}

new Vue({
  el: '#app',
  render: createComponent => createComponent(App)
})
```

​	在分析数据驱动的章节中，我们知道 `render` 函数渲染 `VNode` 最终是调用  `_createElement` 实现的，`_createElement`函数通过传递的参数 `tag` 来判断，如果`tag`是一个普通的 html 标签，就调用 `new VNode(...)`创建 一个`ElementVNode（元素节点）` ，如果是一个组件，就调用 `createComponent` 创建一个 `ComponentVNode（组件节点）`，源码如下：

​	源码目录：`src/core/vdom/create-element.js`

```js
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n' +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

​	上面的例子中我们在 `render` 函数中传入全局组件 `APP` 创建 `VNode`对象，最终`_createElement` 调用`createComponent` 创建一个 `ComponentVNode（组件节点）`，接下来我们分析`createComponent`的源码实现。

### 2. `createComponent`

​	源码目录：`src/core/vdom/create-component.js`

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  // 获得基础构造器baseCtor
  // 这里的context是指向vm实例
  // 在'globalp-api/index.js'中，可以看到option._base指向的是Vue
  // 而在'core/instance/init.js'中，已经将全局的options与vm实例的options合并，这样baseCtor指向的就是Vue
  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    // 对组件的构造器Ctor进行扩展，实际上执行的是Vue.extend。
    // extend函数在'core/gloabal-api/extend.js'中定义
    // extend函数主要的功能是返回一个组件构造器（函数），拥有Vue相同的功能。
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  // 判断是不是函数，不是的话则抛出警告
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  // 处理组件的钩子函数
  installComponentHooks(data)

  // return a placeholder vnode
  // 注意：
  // 这个vnode中的children定义的是undefined，
  // 而在最后一个参数componentOptions中，传入了children，最后返回vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

​	通过源码我们可以清除的分析到组件渲染这个 case 主要执行以下 3 个关键步骤:

​		(1) 构造子类构造函数；

​		(2) 安装组件钩子函数；

​		(3) 实例化 vnode ；

#### 	2.1 构造子类构造函数

​		源码目录：`src/core/vdom/create-component.js`

```js
// 获得基础构造器baseCtor
// 这里的context是指向vm实例
// 在'globalp-api/index.js'中，可以看到option._base指向的是Vue
// 而在'core/instance/init.js'中，已经将全局的options与vm实例的options合并，这样baseCtor指向的就是Vue
const baseCtor = context.$options._base

// plain options object: turn it into a constructor
if (isObject(Ctor)) {
  // 对组件的构造器Ctor进行扩展，实际上执行的是Vue.extend。
  // extend函数在'core/gloabal-api/extend.js'中定义
  // extend函数主要的功能是返回一个组件构造器（函数），拥有Vue相同的功能。
  Ctor = baseCtor.extend(Ctor)
}
```

​		上面的例子，形参 `Ctor` 接受到的是一个 `App` 对象，所以调用 `baseCtor.extend(Ctor)` 函数构造子类构造函。这里的`context`是指向`vm`实例，在`globalp-api/index.js`中，可以看到`option._base`指向的是`Vue`。

​		源码目录：`src/core/globalp-api/index.js`

```js
// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue
```

​		而在`core/instance/init.js`中，已经将全局的`options`与`vm`实例的`options`合并，这样`baseCtor`指向的就是`Vue`。

​		源码目录：`src/core/instance/init.js`

```js
// 传入的options和vue自身的options进行合并
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

​		这样就把 `Vue` 上的一些 `options` 扩展到了 `vm.$option` 上， 所以我们也就能通过 `vm.$options._base`拿到 `Vue` 这个构造函数了。 `mergeOptions` 的功能是把 Vue 构造函数的 `options` 和用户传入的 `options` 做一层合并到`vm.$option`。

​		源码目录：`src/core/globalp-api/extend.js`

```js
  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    // Super指向Vue
    const Super = this
    // 指定一个SuperId
    const SuperId = Super.cid
    // 定义一个缓存构造器cachedCtors用来缓存构造器
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    // 检查组件的名字是否合法
    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name)
    }

    // 创建一个sub函数，用来继承Super（Vue）
    const Sub = function VueComponent (options) {
      this._init(options)
    }
    // 这里的继承使用的是Object.create()纯对象，即原型继承
    Sub.prototype = Object.create(Super.prototype)
    // 该函数的功能是把某个对象（对应这里的Sub.prototype）的__proto__属性关联到指定的对象
    Sub.prototype.constructor = Sub
    // 对象Sub本身扩展一些属性
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    // 对Sub的props和computed做初始化
    // 并扩展一些方法和属性
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    // 将Sub缓存起来，下次如果对应的cachedCtors中有对应的值，就直接返回，不用再创建一个组件的构造器
    cachedCtors[SuperId] = Sub
    return Sub
  }
```

​		分析源码我们可以得到结论是：`Vue.extend` 的作用就是构造一个 Vue 的子类（原型继承）。

​		`Vue.extend` 主要做了一下几件事：

​			(1) 把一个纯对象转换一个继承于 Vue 的构造器 Sub;

​			(2) 对象Sub本身扩展一些属性;

​			(3) 对Sub的props和computed做初始化;

​			(3) 将Sub缓存，避免多次执行 `Vue.extend` 的时候对同一个子组件重复构;

​		这样当我们去实例化 Sub 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑。

​		源码目录：`src/core/globalp-api/extend.js`

```js
const Sub = function VueComponent (options) {
  this._init(options)
}
```



#### 	2.2 安装组件钩子函数

​		我们之前提到 `Vue.js` 使用的 `Virtual DOM` 参考的是开源库[`snabbdom`](https://github.com/snabbdom/snabbdom)，它的一个特点是在 `VNode` 的 `patch` 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，`Vue.js` 也是充分利用这一点，在初始化一个 `Component` 类型的` VNode` 的过程中实现了几个钩子函数:

​		源码目录：`src/core/vdom/create-component.js`

```js
  // install component management hooks onto the placeholder node
  // 处理组件的钩子函数
  installComponentHooks(data)
```

​		源码目录：`src/core/vdom/create-component.js`

```js
function installComponentHooks (data: VNodeData) {
  // 获取到data中的hook
  const hooks = data.hook || (data.hook = {})
  // 循环hooksToMerge进行判断，如果data中存在该hook，则合并
  // 不存在则直接添加到data中
  // hooksToMerge定义为componentVNodeHooks的keys
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}
```

​		`installComponentHooks` 的功能是把 `componentVNodeHooks` 定义的钩子函数合并到 `data.hook`，在 VNode 执行 patch 的过程中执行相关的钩子函数。

​		这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存 在 中，那么通过执行 `mergeHook` 函数做合并，这个逻辑很简单，就是在最终执行的时 候，依次执行这两个钩子函数即可。

​		其中 `componentVNodeHooks` 定义如下：

​		源码目录：`src/core/vdom/create-component.js`

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}

const hooksToMerge = Object.keys(componentVNodeHooks)
```



#### 	2.3 实例化 `vnode`

​		源码目录：`src/core/vdom/create-component.js`

```js
// return a placeholder vnode
// 注意：
// 这个vnode中的children定义的是undefined，
// 而在最后一个参数componentOptions中，传入了children，最后返回vnode
const name = Ctor.options.name || tag
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
```

​		最后通过 `new` 一个 `VNode` 实例化一个 `vnode` 。

​		注意：这个 `vnode` 中的 `children` 定义的是`undefined`，不同与 `ElementVNode（元素节点）`的 `vnode` 。

### 3. `patch`

​		通过数据驱动的分析我们知道，当我们通过 `createComponent` 创建了组件 `VNode`，接下来会走到 `vm._update` ，执行 `vm.__patch__ ` 去把 `VNode` 转换成真正的 `DOM` 节点。这个过程我们在前一章已经分析过了，但是针对一个普通的 `VNode` 节点，接下来我们来看看组件的 `VNode` 会有哪些不一样的地方。

#### 	3.1 `createComponent`

​		`patch` 的过程会调用 `createElm` 创建元素节点。

​		源码目录：`src/core/vdom/patch.js`

```js
 function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode)
    }

    vnode.isRootInsert = !nested // for transition enter check
    // 创建组件的关键逻辑
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode) // setScope css作用域相关

      /* istanbul ignore if */
      if (__WEEX__) {
        // in Weex, the default insertion order is parent-first.
        // List items can be optimized to use children-first insertion
        // with append="tree".
        const appendAsTree = isDef(data) && isTrue(data.appendAsTree)
        if (!appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
        createChildren(vnode, children, insertedVnodeQueue)
        if (appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
      } else {
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm) // refElm参考节点
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
```

​		首先判断 `createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值，如果为 `true` 直接结束。

​		源码目录：`src/core/vdom/patch.js`

```js
 function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    let i = vnode.data // 获取到data对象
    if (isDef(i)) { // 判断data对象存在
      // 判断vode对象中存在componentInstance属性并且data对象中存在keepAlive属性
      const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
      // 判断data对象上存在钩子对象，如果存在赋值给i
      // 判断i上是否存在init方法，如果存在赋值给i
      // 两项对存在则执行init钩子
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */)
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
```

​		`createComponent` 函数中，首先对 `vnode.data ` 做了一些判断:

​			(1) 如果 vnode 是一个组件VNode，那么条件会满足；

​			(2) 得到 i 就是 init 钩子函数；

#### 	3.2 `init`

​		源码目录：`src/core/vdom/create-component.js`

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
```

​		分析源码可以知道`init` 是通过调用 `createComponentInstanceForVnode` 创建一个 Vue 的实例，然后调用 `$mount` 方法挂载子组件。

​		⚠️ 注意：暂时不考虑 `keep-alive`。

#### 	3.3 `createComponentInstanceForVnode`

​		源码目录：`src/core/vdom/create-component.js`

```js
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any, // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // check inline-template render functions
  const inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

​		从上面的源码可以看出，`createComponentInstanceForVnode` 函数构造的一个内部组件的参数，然后执行 `new vnode.componentOptions.Ctor(options)` 。这里的 `vnode.componentOptions.Ctor` 对应的就是子组件的构造函数。

​		我们上一节分析了它(`vnode.componentOptions.Ctor`)实际上是继承于 `Vue` 的一个构造器 `Sub` ，相当于 `new Sub(options)` 。

​		这里有几个关键参数要注意几个点:

​			(1) ` _isComponent` 为 `true` 表示它是一个组件;

​			(2) `_parentVnode` 表示当前激活的组件实例（注意，这里比较有意思的是如何拿到组件实例，后面会介绍）；

​		所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的 `_init` 方法，这个过程有一些和之前不同的地方需要挑出来说。

#### 	3.4 `Vue.prototype._init`

​		源码目录：`src/core/instance/init.js`

```js
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  // ...
  // a flag to avoid this being observed
  // 避免被响应式的标识
  // 这里可以暂时理解新建observer实例就是让数据响应式
  vm._isVue = true
  // merge options
  // 有子组件时，options._isComponent才会为true
  if (options && options._isComponent) { // Vue实例是组件
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
    initInternalComponent(vm, options)
  } else {
    // 传入的options和vue自身的options进行合并
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

​		这里首先是合并 `options` 的过程有变化，` _isComponent`  为 `true`，所以走到了`initInternalComponent(vm, options)`。

#### 	3.5 `initInternalComponent`

​		源码目录：`src/core/instance/init.js`

```js
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

​		这函数函数的主要逻辑有以下几点：

​			(1) `opts.parent = options.parent`;

​			(2) `opts._parentVnode = parentVnode`;

​		这两点的主要作用是把我们传递进来的参数合并到 `vm.$options`。

​		最后回到 `_init`函数中，`_init` 中 `vm.$options.el` 为false，由于组件初始化的时候是不传 `el` 的，因此组件是自己接管了`$mount` 过程。

​		回到组件 `init`的过程，`componentVNodeHooks` 的 `init` 钩子函数，在完成实例化的 `_init`后，接着会执行 `child.$mount(hydrating ? vnode.elm : undefined, hydrating)` ,相当于执行`child.$mount(undefined, false)`，它最终会调用 `mountComponent` 方法，进而执行 `vm._render()` 方法。

#### 	3.6 `Vue.prototype._render`

​		源码目录：`src/core/instance/render.js`

```js
Vue.prototype._render = function (): VNode {
    // this是Vue实例
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      // 核心方法，返回一个vnode
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      // ...
    } finally {
      currentRenderingInstance = null
    }
    // ...
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```

​		分析源码，可以得出 `_parentVnode` 就是当前组件的父 `VNode` ，而 `render` 函数生成的 `vnode` 当前组件的渲染  `vnode` 。

​		`vnode.parent = _parentVnode`从这里可以看出`vnode` 的 `parent` 指向 `_parentVnode `也就是 `vm.$vnode`(`vm.$vnode = _parentVnode`)，它们是一种父子的关系。

#### 	3.7 `Vue.prototype._update`

​		我们知道在执行完 `vm._render` 生成` VNode` 后，接下来就要执行 `vm._update` 来看一下组件渲染的过程中有哪些需要注意的。		

​		源码目录：`src/core/instance/lifecycle.js`

```js
// 保持当前上下文的 Vue 实例
export let activeInstance: any = null

Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent's updated hook.
}
```

​		`_update` 主要执行一下几个过程：

​			(1) `export let activeInstance: any = null` 中 `activeInstance` 是全局变量，作用就是保持当前上下文的 Vue 实例。并且在之前我们调用 `createComponentInstanceForVnode` 方法的时候从 `lifecycle.js ` 模块获取,并且作为参数传入的。因为实际上 `JavaScript` 是一个单线程，`Vue` 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 `Vue` 实例是什么，并把它作为子组件的父 `Vue` 实例。之前我们提到过对子组件的实例化过程先会调用 `initInternalComponent`(`Vue.prototype._init = function (options?: Object) {}`方法中)合并 `options`， 把 `parent` 存储在 `vm.$options` 中，在 `$mount` 之前会调用 `initLifecycle(vm)`方法:

​		源码目录：`src/core/instance/lifecycle.js`

```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}

```

​				可以看到 `vm.$parent` 就是用来保留当前 `vm` 的父实例，并且通过 `parent.$children.push(vm)` 来把当前的 `vm` 存储到父实例的 `$children` 中。

​			(2) `const restoreActiveInstance = setActiveInstance(vm)`:在`vm._update `的过程中，把当前的 `vm` 赋值给 `activeInstance` ，同时通过 `const prevActiveInstance = activeInstance ` 用 `prevActiveInstance` 保留上一次的 `activeInstance`。实际上，`prevActiveInstance` 和当前的 `vm` 是一个父子关系，当一个 `vm` 完成它所有子树的`patch` 或者 `update` 过程后，`activeInstance`回到它的父实例，这样就完 美地保证了`createComponentInstanceForVnode` 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 `Vue` 实例，并在 `_init` 的过程中，通过 `vm.$parent` 把这个父子关系保留。

​		源码目录：`src/core/instance/lifecycle.js`

```js
export function setActiveInstance(vm: Component) {
  const prevActiveInstance = activeInstance
  activeInstance = vm
  return () => {
    activeInstance = prevActiveInstance
  }
}
```

​			(3) `vm._vnode = vnode`, `vnode` 是通过 `vm._render()` 返回的组件渲染 `VNode`，`vm._vnode` 和 `vm.$vnode`关系是一种父子关系，即 `vm._vnode.parent === vm.$vnode`。

​			(4) `__patch__`: `vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)`

​		源码目录：`src/core/vdom/patch.js`

```js
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    // ...
    let isInitialPatch = false
    const insertedVnodeQueue = []
    
    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // ...
    }
    // ...
  }

```

​				这里又回到了本节开始的过程，之前分析过负责渲染成 `DOM` 的函数是 `createElm` ，注意这里我们只 传了 2 个参数，所以对应的 `parentElm` 是 `undefined` 。我们再来看看它的定义:

​		源码目录：`src/core/vdom/patch.js`

```js
 function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    // ...
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      // ...

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode) // setScope css作用域相关

      /* istanbul ignore if */
      if (__WEEX__) {
        // ...
      } else {
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm) // refElm参考节点
      }

      // ...
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
```

​			注意，这里我们传入的 `vnode` 是组件渲染的 `vnode` ，也就是我们之前说的 `vm._vnode`，如果组件的根节点是个普通元素，那么 `vm._vnode` 也是普通的 `vnode` ，这里`createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值是 `false`。接下来的过程就和我们上一章一样 了，先创建一个父节点占位符，然后再遍历所有子 `VNode` 递归调用 `createElm` ，在遍历的过程中，如果遇到子` VNode` 是一个组件的 `VNode`，则重复本节开始的过程，这样通过一个递归的方式就可以完 整地构建了整个组件树。

​			由于我们这个时候传入的 `parentElm` 是空，所以对组件的插入，在` createComponent` 有这么一段逻辑:

​		源码目录：`src/core/vdom/patch.js`

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    let i = vnode.data // 获取到data对象
    if (isDef(i)) { // 判断data对象存在
      // ...
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */)
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
```

​			在完成组件的整个过程后，最后执行` insert(parentElm, vnode.elm, refElm)` 完成组件的 `DOM` 插入，如果组件过程中又创建了子组件，那么`DOM` 的插入顺序是先子后父。

### 4. `合并配置`



### 5. `生命周期`



### 6. `组件注册`



### 7. `异步组件`





