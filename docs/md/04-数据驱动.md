## Vue数据驱动



---

[TOC]

---

​		传统的前端数据交互是用Ajax从服务端获取数据，然后操作DOM来改变视图；或者前端交互要改变数据时，又要再来一次上述步骤，而手动操作DOM是一个繁琐的过程且易出错。

​		什么是[数据驱动](https://segmentfault.com/a/1190000013276124)？

​		Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它让开发者省去了操作DOM的过程，只需要改变数据。Vue会通过Dircetives指令，对DOM做一层封装，当数据发生改变会通知指令去修改对应的DOM，数据驱动DOM变化，**DOM是数据的一种自然映射**。Vue还会对操作进行监听，当视图发生改变时，vue监听到这些变化，从而改变数据，这样就形成了数据的双向绑定。

​		接下来，我们会从源码角度来分析 Vue 是如何实现的，分析过程会以**主线代码为主**，重要的分支逻辑会放在之后单独分析。数据驱动还有一部分是数据更新驱动视图变化，这一块内容我们也会在之后的章节分析，这一章我们的目标是弄清楚模板和数据如何渲染成最终的 DOM。

### 1. [Vue构造函数](https://segmentfault.com/a/1190000014488094)

#### 	1.1 new

​		首先我们带着一个问题去分析源码：**[new Vue](https://www.jianshu.com/p/ba840beb06c7)** **发生了什么？**

​		在 `JavaScript` 中 `new` 主要做了一下几件事：

​			(1)、创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型。

​			(2)、属性和方法被加入到 `this` 引用的对象中。

​			(3)、新创建的对象由 `this`  所引用，并且最后隐式的返回 `this` 。

```js
// Javascript的new关键字主要的作用是继承
// new一共经历4个阶段
// 1、创建一个空对象
var obj = new Object();

// 2、设置原型链
// 此时便建立了obj对象的原型链

obj._proto_ = Object.prototype;

// 3、让Func的this指向obj，并执行Func函数体
Object.call(obj);

// 4、判断Func的返回值类型
// 如果是值类型，返回obj；
// 如果是引用类型，返回这个引用类型的对象。
return typeof result === 'obj'? result : obj;
```

#### 	1.2 Vue

​		源码目录：`src/core/instance/index.js`

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

​		可以看到Vue构造函数是一个很简洁的`function`工厂模式声明的一个构造函数， Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法。

### 2. _init(options)函数

#### 	2.1 _init源码分析

 	   源码目录：` src/core/instance/init.js `

```js
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    /* 
    * 测试代码性能
    * 参考：https://segmentfault.com/a/1190000014479800
    */
    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    // 避免被响应式的标识
    // 这里可以暂时理解新建observer实例就是让数据响应式
    vm._isVue = true
    // merge options
    // 有子组件时，options._isComponent才会为true
    if (options && options._isComponent) { // Vue实例是组件
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
      // 优化components属性
      initInternalComponent(vm, options)
    } else {
      // 传入的options和vue自身的options进行合并
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* 
    * istanbul ignore else 
    * 参考：https://segmentfault.com/a/1190000014824359
    */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm) // 初始化一些和生命周期相关的内容
    initEvents(vm) // 初始化事件相关属性，当有父组件的方法绑定在子组件时候，供子组件调用
    initRender(vm) // 初始化渲染，添加slot属性
    callHook(vm, 'beforeCreate') // 调用beforeCreate钩子
    initInjections(vm) // resolve injections before data/props
    initState(vm) // 初始化数据，进行双向绑定 state/props
    initProvide(vm) // resolve provide after data/props, 注入provider的值到子组件中
    callHook(vm, 'created') // 调用created钩子

    /* istanbul ignore if */
    // 计算覆盖率时忽略下列代码
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el) // 把模板转换成render函数
    }
  }
```

​		Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始 化 data、props、computed、watcher 等等。

### 3. Vue实例挂载

#### 	3.1 新定义的`$mount`

​		在`_init()`函数的最后，执行了`vm.$mount()`。vm代表的是当前vue实例也就是构造函数被调用后的`this`指向。

​		`$mount`是何时在vue上声明的呢？这次并不是在上边的初始化函数中完成声明的。因为 $mount 这个方法的实现是和平台、构建方式都相关，所以在不同构建入口文件中有不同的定义。如：`src/platform/web/entry-runtime-with-compiler.js` 、`src/platform/web/runtime/index.js` 、`src/platform/weex/runtime/index.js` 中都有定义。

​		在这里我门以compiler版本为例，进行源码分析。

​		**[vue版本说明](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释)**

​		源码目录：` src/platform/web/entry-runtime-with-compiler.js `

```js

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      // 模板编译成render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

​		首先缓存原型上的方法 `const mount = Vue.prototype.$mount`, 然后重新定义该方法。原型上声明的 `$mount`方法在 `src/platform/web/runtime/index.js` 中定义,这个方法会被`runtime only`版本和`runtime compiler`版本中复用。

​		新定义的`$mount` 方法分析：

​		首先方法接收两个参数 `el` 和 `hydrating` ,方法内部对 `el` 进行判断和限制不能是 `document.body` 和 `document.documentElement` ，即不能是 `body`节点  和 `html节点`。

​		接下来判断 `render` 函数是否定义，没有定义就将 `el` 或 `template` 编译成 `render` 函数。

​		 ⚠️ 注意 ：这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 属性，最终都会转换成 render 方法。

​		从源码中可以看出编译调用了 `compileToFunctions` 方法实现。

​		最后通过调用缓存下来的原型方法 `mount.call(this, el, hydrating)` 挂载DOM。

#### 	3.2 `Vue`原型上的`$mount`

​		源码目录：` src/platform/web/runtime/index.js `

```js
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

​		`$mount`方法接收两个参数 `el` 和 `hydrating` ，首先判断 `el` 存在并且在浏览器环境下调用 `query(el)` 获取到DOM对象，最后调用 `mountComponent(this, el, hydrating)` 方法挂载。

#### 	3.3 `mountComponent`方法

​		源码目录：` src/core/instance/lifecycle.js `

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 调用生命周期钩子beforeMount
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      // 首先vm._update和vm._render这两个方法是定义在Vue原型上的
      // 1.vm._render()把实例渲染成一个虚拟 Node
      // 2.vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // 调用生命周期钩子mounted
    callHook(vm, 'mounted')
  }
  return vm
}
```

​		`mountComponent` 方法的核心是通过实例化一个渲染 `watcher`，内部执行 `updateComponent`， 最终调用 `vm._update`更新 `DOM` 。

​		`Watcher` 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 `vm` 实例中的监测的数据发生变化的时候执行回调函数。

​		函数最后判断为根节点的时候设置 为 `true` ， 表示这个实例已经挂载了，同时执行 `mounted` 钩子函数。 这里注意 `vm.$vnode` 表示  `Vue` 实例的父虚拟` Node`，所以它为 `Null` 则表示当前是根` Vue` 的实例

​		`updateComponent` 方法的核心是 `vm._update` 和 `vm._render()` ：

​			-- 首先vm._update和vm._render这两个方法是定义在Vue原型上的；

​			-- vm._render()把实例渲染成一个虚拟 Node；

​			-- vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点

### 4. render

#### 	4.1 `_render`

​		`Vue` 的 `_render` 方法是用来把实例渲染成一个虚拟 `Node`。是在 `renderMixin(Vue)` 执行时声明的。它的定义在 `src/core/instance/render.js` 文件中。

​		源码目录：` src/core/instance/render.js `

```js
    Vue.prototype._render = function (): VNode {
    // this是Vue实例
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      // 核心方法，返回一个vnode
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = null
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```

​		这段代码中的核心方法是 `vnode = render.call(vm._renderProxy, vm.$createElement)` 。

​		`Vue` 推荐在绝大多数情况下使用模板来创建你的 `HTML`。然而在一些场景中，你真的需要 `JavaScript` 的完全编程的能力。这时你可以用**渲染函数**，它比模板更接近编译器。[`render详情查看这里`](https://cn.vuejs.org/v2/guide/render-function.html)

​		`render` 函数最终 执行的是下面这段代码，`with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(msg))])}` ，其中 `_c(...)` 实质是 `createElement` 方法就是 `vm.$createElement` 方法。

#### 	4.2 `initRender`

​		源码目录：` src/core/instance/render.js `

```js
export function initRender (vm: Component) {
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  // 模板编译成的 render 函数使用
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  // 用户手写 render 方法使用
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  const parentData = parentVnode && parentVnode.data

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)
    }, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)
    }, true)
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)
  }
}

```

​		`vm._c` : 模板编译成的 `render ` 函数使用;

​		`vm.$createElement` : 用户手写 `render` 方法使用;

​		这俩个方法支持的参数相同，并且内部都调用了 `createElement` 方法。

### 5. Virtual DOM

#### 	5.1 什么是 `Virtual Dom`？

​		`Virtual Dom` 可以看做一棵模拟了 `DOM` 树的 `JavaScript` 树，其主要是通过 `vnode` ,实现一个无状态的组件，当组件状态发生更新时，然后触发 `Virtual Dom` 数据的变化，然后通过 `Virtual Dom` 和真实 `DOM` 的比对，再对真实`DOM ` 更新。可以简单认为 `Virtual Dom` 是真实 `DOM` 的缓存。

#### 	5.2 为什么用 `Virtual Dom`？

​		我们知道，当我们希望实现一个具有复杂状态的界面时，如果我们在每个可能发生变化的组件上都绑定事件，绑定字段数据，那么很快由于状态太多，我们需要维护的事件和字段将会越来越多，代码也会越来越复杂，于是，我们想我们可不可以将视图和状态分开来，只要视图发生变化，对应状态也发生变化，然后状态变化，我们再重绘整个视图就好了。

​		这样的想法虽好，但是代价太高了，于是我们又想，能不能只更新状态发生变化的视图？于是 `Virtual Dom` 应运而生，状态变化先反馈到 `Virtual Dom` 上，`Virtual Dom` 在找到最小更新视图，最后批量更新到真实 `DOM` 上，从而达到性能的提升。

​		除此之外，从移植性上看，`Virtual Dom` 还对真实 `DOM` 做了一次抽象，这意味着 `Virtual Dom` 对应的可以不是浏览器的 `DOM`，而是不同设备的组件，极大的方便了多平台的使用。如果是要实现前后端同构直出方案，使用 `Virtual Dom` 的框架实现起来是比较简单的，因为在服务端的 `Virtual Dom` 跟浏览器 `DOM` 接口并没有绑定关系。

​		`Virtual DOM`  简单的说就是一颗树，一颗以 `javaScript` 对象 `（VNode）` 作为基础的树，用对象的属性来描述节点，因此这个对象至少包含标签名 `（tag）` 、属性 `（attrs）` 、和 子元素对象 `（chuildren）`。

　　`Virtual DOM`  的最终目的是将虚拟的节点渲染到视图上，其实它主要做了两件事：

​			(1)、提供与真实 `DOM` 节点对应的虚拟节点` VNode`；

​			(2)、将虚拟节点 `VNode` 和旧虚拟节点` (oldVNode)` 进行对比，然后更新视图；

　　`Virtual DOM`  的优势：

　　　　(1)、具备跨平台的优势；

　　　　(2)、操作` DOM` 慢，`js` 运行的效率高；`vue`  将 `DOM` 对比放在 `js` 层，提高效率，`Virtual DOM` 本质上其实就是 `js`  和 `dom` 之间的一个缓存，通过` patching` 算法计算出真正需要更新的节点，最大限度的减少 `DOM` 操作；

　　　　(3)、提升渲染的性能；`DOM`操作的减少，可以避免更多的回流和重绘等，更加高效的提高性能。

#### 	5.3 `Virtual DOM` 和 `DOM`对比

​		下面看一下真实 `DOM` 的属性和`Virtual DOM`的定义：

```js
// 真实 DOM 所有属性
/*
align title lang translate dir hidden accessKey draggable spellcheck autocapitalize contentEditable isContentEditable inputMode offsetParent offsetTop offsetLeft offsetWidth offsetHeight style innerText outerText oncopy oncut onpaste onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror onfocus onformdata oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting onwheel onauxclick ongotpointercapture onlostpointercapture onpointerdown onpointermove onpointerup onpointercancel onpointerover onpointerout onpointerenter onpointerleave onselectstart onselectionchange onanimationend onanimationiteration onanimationstart ontransitionend dataset nonce autofocus tabIndex click attachInternals focus blur enterKeyHint onpointerrawupdate namespaceURI prefix localName tagName id className classList slot attributes shadowRoot part assignedSlot innerHTML outerHTML scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight attributeStyleMap onbeforecopy onbeforecut onbeforepaste onsearch elementTiming previousElementSibling nextElementSibling children firstElementChild lastElementChild childElementCount onfullscreenchange onfullscreenerror onwebkitfullscreenchange onwebkitfullscreenerror hasAttributes getAttributeNames getAttribute getAttributeNS setAttribute setAttributeNS removeAttribute removeAttributeNS toggleAttribute hasAttribute hasAttributeNS getAttributeNode getAttributeNodeNS setAttributeNode setAttributeNodeNS removeAttributeNode attachShadow closest matches webkitMatchesSelector getElementsByTagName getElementsByTagNameNS getElementsByClassName insertAdjacentElement insertAdjacentText setPointerCapture releasePointerCapture hasPointerCapture insertAdjacentHTML requestPointerLock getClientRects getBoundingClientRect scrollIntoView scroll scrollTo scrollBy scrollIntoViewIfNeeded animate computedStyleMap before after replaceWith remove prepend append querySelector querySelectorAll requestFullscreen webkitRequestFullScreen webkitRequestFullscreen ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE DOCUMENT_POSITION_DISCONNECTED DOCUMENT_POSITION_PRECEDING DOCUMENT_POSITION_FOLLOWING DOCUMENT_POSITION_CONTAINS DOCUMENT_POSITION_CONTAINED_BY DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC nodeType nodeName baseURI isConnected ownerDocument parentNode parentElement childNodes firstChild lastChild previousSibling nextSibling nodeValue textContent hasChildNodes getRootNode normalize cloneNode isEqualNode isSameNode compareDocumentPosition contains lookupPrefix lookupNamespaceURI isDefaultNamespace insertBefore appendChild replaceChild removeChild addEventListener removeEventListener dispatchEvent 
*/
```

​		源码目录：` src/core/vdom/vnode.js`

```js
/* 
* 通过new实例化的VNode可以分为：
*  EmptyVNode（注释节点）
*  TextVNode（文本节点）
*  ElementVNode（元素节点）
*  ComponentVNode（组件节点）
*  CloneVNode（克隆节点）
*/
export default class VNode {
  tag: string | void; // 元素标签
  data: VNodeData | void; // 属性
  children: ?Array<VNode>; // 子元素列表
  text: string | void;
  elm: Node | void; //  对应的真实 DOM 元素
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node // 是否被标记为静态节点
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }
  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  get child (): Component | void {
    return this.componentInstance
  }
}

```

​		实际上 `Vue.js` 中 Virtual `DOM` 是借鉴了一个开源库[ `snabbdom`](https://github.com/snabbdom/snabbdom) 的实现，然后加入了一些 `Vue.js` 特色的东⻄。我建议大家如果想深入了解 `Vue.js` 的 `Virtual DOM` 前不妨先阅读这个库的源码，因为它更加简单和纯粹。

​		其实 `VNode` 是对真实 `DOM` 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子 节点、键值等，其它属性都是都是用来扩展 `VNode` 的灵活性以及实现一些特殊` feature` 的。由于 `VNode` 只是用来映射到真实 `DOM` 的渲染，不需要包含操作` DOM` 的方法，因此它是非常轻量和简单的。

​		`Virtual DOM` 除了它的数据结构的定义，映射到真实的 `DOM` 实际上要经历 `VNode` 的 `create`、`diff`、 `patch` 等过程。那么在 `Vue.js` 中，`VNode` 的 `create` 是通过之前提到的 `createElement` 方法创建的。

​		主要涉及的几个重要概念：渲染函数、`VNode`虚拟节点、`patch`(`patching`算法)；

　　　　渲染函数：主要是用来生成` virtual DOM` 的；`vue` 虽然推荐使用 `template` 来构建页面，但是其实也是支持直接写渲染函数的；

　　　　`VNode`虚拟节点：它是节点描述，可以代表一个真实的`DOM`，最终真实的`DOM`就是通过 `createElement` 将`VNode` 渲染成真实的`DOM`的；

　　　　`patch(也叫patching算法)`：它是虚拟`DOM`最核心的部分，`VNode`最终就是经过这个算法成为真实的`DOM`的，这个过程是对比新旧节点之间的不同，然后根据对比结果找出需要更新的节点进行更新；

### 6. createElement

#### 	6.1 `createElement` 方法

​		`Vue.js` 利用` createElement` 方法创建 `VNode`。

​		源码目录：` src/core/vdom/create-element.js`

```js

const SIMPLE_NORMALIZE = 1
const ALWAYS_NORMALIZE = 2

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}
```

​		从上面代码中可以看出 `createElement` 是对 `_createElement` 的二次封装，主要是为了处理参数灵活传递。

#### 	6.2 `_createElement` 方法

​		源码目录：` src/core/vdom/create-element.js`

```js
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n' +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```



​		`_createElement`方法的参数分别为：

​		（1）`context: Component` : 表示 `VNode` 的上下文环境，它是` Component` 类型;

​		（2）`tag?: string | Class<Component> | Function | Object` : 表示标签，它可以是一个字符串，也可以是一个 `Component`;

​		（3）`data?: VNodeData` : 表示 `VNode` 的数据，它是一个 `VNodeData` 类型，可以在 `flow/vnode.js` 中找打它的定义；

​		（4）`children?: any `: 表示当前 `VNode` 的子节点，它是任意类型;

​		（5）`normalizationType?: number `: 表示子节点规范的类型。

​		`_createElement` 函数主要做了两件事，一是 `children` 的规范化；二是 `VNode` 的创建，下面我们分别从源码方面来分析这两个流程。

#### 	6.3 `children` 规范化

​		由于 `Virtual DOM` 实际上是一个树状结构，每一个 `VNode` 可能会有若干个子节点，这些子节点应该也 是 `VNode` 的类型。 `_createElement `接收的第 4 个参数 `children` 是任意类型的，因此我们需要把它们 规范成 `VNode` 类型。

​		源码目录：`src/core/vdom/helpers/normalzie-children.js`

```js

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
export function normalizeChildren (children: any): ?Array<VNode> {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

```

​		`simpleNormalizeChildren`: 方法调用场景是` render`  函数当函数是编译生成的。理论上编译生成的 `children` 都已经是 `VNode` 类型，但这里有一个例外，就是 `function component` 函数式组件返回的是一个数组而不是一个根节点，所以会通过 `Array.prototype.concat` 方法把整个 `children`  数组打平，让它的深度只有一层。

​		`normalizeChildren`: 方法的调用场景有 2 种，一个场景是` render ` 函数是用户手写的，当 `children` 只有一个节点的时候，Vue.js 从接口层面允许用户把 `children` 写成基础类型用来创建单个简单的文本节点，这种情况会调用  `createTextVNode` 创建一个文本节点的 `VNode` ;另一个场景是当编译 `slot 、 v-for` 的时候会产生嵌套数组的情况，会调用 `normalizeArrayChildren` 方法， 接下来看一下它的实现。

​		源码目录：`src/core/vdom/helpers/normalzie-children.js`

```js
function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c))
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}
```

​		`normalizeArrayChildren` 接受的两个参数分别为：

​			`children: any` : 表示要规范的子节点；

​			`nestedIndex?: string`  : 表示嵌套的索引，因为单个 `child` 可能是一个数组类型；

​		分析完接受的参数以及它们代表的意思，接下来我们分析此函数内部的执行逻辑：

​			 遍历 `children` 获取每一子项 `c` ,然后判断 `c` 的数据类型：

​				如果是一个数组类型，则递归调用 `normalizeArrayChildren` ;

​				如果是基础类型，则通过 `createTextVNode` 方法转换成 VNode 类型;

​				否则就是 `VNode`类型，如果 children 是一个列表并且列表还存在嵌套的情况，则根据

nestedIndex 去更新它的 key；

​			⚠️ 注意： 在遍历的过程中，对这 3 种情况都做了如下处 理:如果存在两个连续的` text` 节点，会把它们合并成一个 `text` 节点,代码为 `res[lastIndex] = createTextVNode(...)`。

​			最后经过规范化后的 `children` 是一个 `VNode` 类型的数组 `(Array)`。

#### 	6.4 `VNode` 创建

​		源码目录：` src/core/vdom/create-element.js`

```js
let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
```

​		首先判断 `tag` 的类型：

​			如果是 string 类型，则接着判断:

​				如果是内置的一些节点，则直接创建一个普通 VNode；

​				如果是为已注册的组件名，则通过 `createComponent` 创建一个组件类型的 `VNode`;

​				否则创建一个未知的标签的 `VNode`；

​			 如果 tag 是一个 `component` 类型，则直接调用 `createComponent` 创建组件类型的 `VNode`;

#### 	6.5 总结

​		通过以上的源码分析，我们知道了 `createElement` 创建 `VNode` 的过程，每个 `VNode` 有 `children` ， `children`  每个元素也是一个 `VNode`，这样就形成了一个 `VNode Tree`，它很好的描述了我们的 ` DOM Tree`。

### 7. update

​		首先 `_update` 方法的作用是把 `VNode` 渲染成真实的 `DOM`。

​		源码目录：` src/core/instance/lifecycle.js`

```js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }
```

​		通过源码我们可以看出 `_update` 接受的参数：

​			（1）`vnode: VNode`，类型是`VNode`，用来描述 `DOM` 节点的虚拟节点；

​			（2）`hydrating?: boolean`，布尔类型的参数是跟ssr相关；

​		`_update` 函数内部最关键的执行了`vm.$el = vm.__patch__(...)`，调用 `vm.__patch__` 去把 `VNode` 转换成真正的 `DOM` 节点。

​		`vm.__patch__` 这个方法实际上在不同的平台，比如` web` 和 `weex` 上的定义是不一样的，因此在 `web` 平台中它的定义在 `src/platforms/web/runtime/index.js` 中。

​		源码目录：`src/platforms/web/runtime/index.js`

```js
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

​		可以看到，甚至在 `web` 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中， 没有真实的浏览器 `DOM` 环境，所以不需要把 `VNode` 最终转换成 `DOM`，因此是一个空函数，而在浏览 器端渲染中，它指向了` patch` 方法。

​		源码目录：`src/platforms/web/runtime/patch.js`

```js
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules = platformModules.concat(baseModules)

export const patch: Function = createPatchFunction({ nodeOps, modules })
```

​		从源码可看出 `patch`方法是函数 `createPatchFunction` 返回的。`createPatchFunction` 接受一个对象类型的参数，此对象包含两个数据项 `nodeOps` 和 ` modules`，其中，`nodeOps` 封装了一系列 DOM 操作的方法，` modules` 定义了一些模块的钩子函数的实现。

​		源码目录：`src/core/vdom/patch.js`

```js

export function createPatchFunction (backend) {
  let i, j
  const cbs = {}

  const { modules, nodeOps } = backend

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }
  
  // ...
  // function createElm() {...}
  // function createComponent() {...}
  // function insert() {...}
  // function createChildren() {...}
  // ...
  return function patch (oldVnode, vnode, hydrating, removeOnly) {...}
}
```

​		从源码可以看出 `createPatchFunction` 函数内部定义可很多辅助函数，最后返回一个 `patch` 方法，这个方法就 赋值给了 函数里调用的 `vm.__patch__` 。

​		在介绍 `patch` 的方法实现之前，我们可以思考一下为何 `Vue.js` 源码绕了这么一大圈，把相关代码分散到各个目录?

​		因为前面介绍过， `patch` 是平台相关的，在 `Web` 和 `Weex` 环境，它们把虚拟 `DOM` 映 射到 “平台 `DOM`” 的方法是不同的，并且对 “`DOM`” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 `nodeOps` 和 `modules` ，它们的代码需要托管在 `src/platforms` 这个大目录下。

​		而不同平台的 `patch` 的主要逻辑部分是相同的，所以这部分公共的部分托管在 `core` 这个大目录下。差异化部分只需要通过参数来区别，这里用到了一个函数柯里化的技巧，通过 `createPatchFunction` 把差异化参数提前固化，这样不用每次调用` patch` 的时候都传递 `nodeOps` 和 `modules` 了，这种编程技巧也非常值得学习。

​		在这里，`nodeOps` 表示对 “平台 `DOM`” 的一些操作方法， `modules` 表示平台的一些模块，它们会在` patch`过程的不同阶段执行相应的钩子函数。

#### 	7.1 首次渲染

​		分析首次渲染之前我们先看一下下面这个简单的例子：

```js
var app = new Vue({
  el: '#app',
  render: function (createElement) {
    return createElement('div', {
      attrs: {
				id: 'app'
      },
		}, this.message)
  },
  data: {
    message: 'Hello Vue!'
	} 
})
```

##### 		7.1.1 `_update`

​			结合上面的例子，我们在调用源码中的 `_update` 方法时，实质上是调用 `vm.__patch__`方法，源码如下：

```js
// initial render
vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
```

​			所以在执行 patch 函数的时候，传入的 `vm.$el` 对应的 是例子中 id 为 app 的 DOM 对象，这个也就是我们在 index.html 模板中写的 `<div id="app"></div>`，`vm.$el`的赋值是在之前 `mountComponent` 函数做的，`vnode` 对应的是调用 `render` 函数的返回值， `hydrating` 在非服务端渲染情况下为 ` false`，`removeOnly` 为 `false`。

##### 		7.1.2 `patch`

​			源码目录：`src/core/vdom/patch.js`

```js
return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) { // 上面例子中vnode不为空
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) { // 上面例子中oldVnode不为空
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else { // 所以程序最终这行下面的逻辑
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
```

​			由于我们传入的 `oldVnode` 实际上是一个 `DOM container`，所以 `isRealElement` 为 `true`，接下来又通过 `emptyNodeAt` 方法把 `oldVnode` 转换成 `VNode` 对象，然后再调用 `createElm` 方法，这个方法在这里非常重要，来看一下它的实现

##### 		7.1.3 `createElm`

​			`createElm` 的作用是通过虚拟节点创建真实的` DOM` 并插入到它的父节点中。

​			源码目录：`src/core/vdom/patch.js`

```js
 function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode)
    }

    vnode.isRootInsert = !nested // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    const data = vnode.data
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode)

      /* istanbul ignore if */
      if (__WEEX__) {
        // in Weex, the default insertion order is parent-first.
        // List items can be optimized to use children-first insertion
        // with append="tree".
        const appendAsTree = isDef(data) && isTrue(data.appendAsTree)
        if (!appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
        createChildren(vnode, children, insertedVnodeQueue)
        if (appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue)
          }
          insert(parentElm, vnode.elm, refElm)
        }
      } else {
        createChildren(vnode, children, insertedVnodeQueue)
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue)
        }
        insert(parentElm, vnode.elm, refElm)
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
```

​			这个方法中首先对调用 `createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值做了判断，如果为 `true`则直接结束，`createComponent` 方法目的是尝试创建子组件。这上面实例中返回值为 `false`。

​			接下来判断 `vnode` 是否包含` tag`，如果包含，先简单对 `tag` 的合法性在非生产环境下做校验，看是否是一个合法标签;然后再去调用平台 `DOM` 的操作去创建 一个占位符元素。

​			接下来调用 `createChildren` 方法去创建子元素，`createChildren` 的逻辑是递归调用 `createElm`，做一次深度优先的遍历算法。

​			在遍历的过程中会把 `vnode.elm` 作为父容器的 `DOM` 节点占位符传入。

​			源码目录：`src/core/vdom/patch.js`

```js
 function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(children)
      }
      for (let i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
    }
  }
```



​			接着再调用 `invokeCreateHooks` 方法执行所有的 create 的钩子并把 `vnode`  `push` 到 `insertedVnodeQueue` 中。

​			源码目录：`src/core/vdom/patch.js`

```js
 function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (let i = 0; i < cbs.create.length; ++i) {
      cbs.create[i](emptyNode, vnode)
    }
    i = vnode.data.hook // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) i.create(emptyNode, vnode)
      if (isDef(i.insert)) insertedVnodeQueue.push(vnode)
    }
  }
```



​			最后执行 `insert(parentElm, vnode.elm, refElm)` 完成组件的 `DOM` 插入，如果组件 `patch` 过程中(递归调用insert)又创建了子组件，那么`DOM` 树节点的插入顺序是先子后父。

​			源码目录：`src/core/vdom/patch.js`

```js
function insert (parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (nodeOps.parentNode(ref) === parent) {
          nodeOps.insertBefore(parent, elm, ref)
        }
      } else {
        nodeOps.appendChild(parent, elm)
      }
    }
  }
```

​			其中 `insertBefore` 和 `appendChild` 是辅助函数。

​			源码目录：`src/platforms/web/runtime/node-ops.js`

```js
export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
  parentNode.insertBefore(newNode, referenceNode)
}

export function appendChild (node: Node, child: Node) {
  node.appendChild(child)
}
```

​			其实就是调用原生 `DOM` 的 `API` 进行 `DOM` 操作， `Vue` 是这样动态创建的 `DOM`。



中。

#### 	7.2 数据更新

​		数据更新部分我们放在响应式原理分析时候再去详细介绍。

#### 	7.3 总结

​		在 `createElm` 过程中，如果 `vnode` 节点如果不包含 `tag` ，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 `vnode` ，它的 `text` 值取的就是之前的 `this.message` 的值 `Hello Vue!` 。

​		再回到 `patch` 方法，首次渲染我们调用了 `createElm` 方法，这里传入的 `parentElm` 是 `oldVnode.elm` 的父元素， 在我们的例子是` id` 为 #`app`  的`div` 的父元素，也就是 `Body`，实际上整个过程就是递归创建了一个完整的 `DOM` 树并插入到 Body 上。
 		最后，我们根据之前递归 `createElm` 生成的 `vnode` 插入顺序队列，执行相关的 `insert` 钩子函数。

### 8. 总结

![vue实例化到挂载到dom流程图](https://github.com/lotosv2010/Vue-SourceCode-Analysis/blob/master/images/04/02%20vue%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%88%B0%E6%8C%82%E8%BD%BD%E5%88%B0dom%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

