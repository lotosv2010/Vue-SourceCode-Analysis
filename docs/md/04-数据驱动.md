## Vue数据驱动



---

[TOC]

---

​		传统的前端数据交互是用Ajax从服务端获取数据，然后操作DOM来改变视图；或者前端交互要改变数据时，又要再来一次上述步骤，而手动操作DOM是一个繁琐的过程且易出错。

​		什么是[数据驱动](https://segmentfault.com/a/1190000013276124)？

​		Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它让开发者省去了操作DOM的过程，只需要改变数据。Vue会通过Dircetives指令，对DOM做一层封装，当数据发生改变会通知指令去修改对应的DOM，数据驱动DOM变化，**DOM是数据的一种自然映射**。Vue还会对操作进行监听，当视图发生改变时，vue监听到这些变化，从而改变数据，这样就形成了数据的双向绑定。

​		接下来，我们会从源码角度来分析 Vue 是如何实现的，分析过程会以**主线代码为主**，重要的分支逻辑会放在之后单独分析。数据驱动还有一部分是数据更新驱动视图变化，这一块内容我们也会在之后的章节分析，这一章我们的目标是弄清楚模板和数据如何渲染成最终的 DOM。

### 1. [Vue构造函数](https://segmentfault.com/a/1190000014488094)

​		首先我们带着一个问题去分析源码：**[new Vue](https://www.jianshu.com/p/ba840beb06c7)** **发生了什么？**

​		在 `JavaScript` 中 `new` 主要做了一下几件事：

​			(1)、创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型。

​			(2)、属性和方法被加入到 `this` 引用的对象中。

​			(3)、新创建的对象由 `this`  所引用，并且最后隐式的返回 `this` 。

```js
// Javascript的new关键字主要的作用是继承
// new一共经历4个阶段
// 1、创建一个空对象
var obj = new Object();

// 2、设置原型链
// 此时便建立了obj对象的原型链

obj._proto_ = Object.prototype;

// 3、让Func的this指向obj，并执行Func函数体
Object.call(obj);

// 4、判断Func的返回值类型
// 如果是值类型，返回obj；
// 如果是引用类型，返回这个引用类型的对象。
return typeof result === 'obj'? result : obj;
```



​		源码目录：`src/core/instance/index.js`

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

​		可以看到Vue构造函数是一个很简洁的`function`工厂模式声明的一个构造函数， Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法。

### 2. _init(options)函数

 	   源码目录：` src/core/instance/init.js `

```js
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    /* 
    * 测试代码性能
    * 参考：https://segmentfault.com/a/1190000014479800
    */
    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    // 避免被响应式的标识
    // 这里可以暂时理解新建observer实例就是让数据响应式
    vm._isVue = true
    // merge options
    // 有子组件时，options._isComponent才会为true
    if (options && options._isComponent) { // Vue实例是组件
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
      // 优化components属性
      initInternalComponent(vm, options)
    } else {
      // 传入的options和vue自身的options进行合并
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* 
    * istanbul ignore else 
    * 参考：https://segmentfault.com/a/1190000014824359
    */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm) // 初始化一些和生命周期相关的内容
    initEvents(vm) // 初始化事件相关属性，当有父组件的方法绑定在子组件时候，供子组件调用
    initRender(vm) // 初始化渲染，添加slot属性
    callHook(vm, 'beforeCreate') // 调用beforeCreate钩子
    initInjections(vm) // resolve injections before data/props
    initState(vm) // 初始化数据，进行双向绑定 state/props
    initProvide(vm) // resolve provide after data/props, 注入provider的值到子组件中
    callHook(vm, 'created') // 调用created钩子

    /* istanbul ignore if */
    // 计算覆盖率时忽略下列代码
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el) // 把模板转换成render函数
    }
  }
```

​		Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始 化 data、props、computed、watcher 等等。

### 3. Vue实例挂载

​		在`_init()`函数的最后，执行了`vm.$mount()`。vm代表的是当前vue实例也就是构造函数被调用后的`this`指向。

​		`$mount`是何时在vue上声明的呢？这次并不是在上边的初始化函数中完成声明的。因为 $mount 这个方法的实现是和平台、构建方式都相关，所以在不同构建入口文件中有不同的定义。如：`src/platform/web/entry-runtime-with-compiler.js` 、`src/platform/web/runtime/index.js` 、`src/platform/weex/runtime/index.js` 中都有定义。

​		在这里我门以compiler版本为例，进行源码分析。

​		**[vue版本说明](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释)**

​		源码目录：` src/platform/web/entry-runtime-with-compiler.js `

```js

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      // 模板编译成render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

​		首先缓存原型上的方法 `const mount = Vue.prototype.$mount`, 然后重新定义该方法。原型上声明的 `$mount`方法在 `src/platform/web/runtime/index.js` 中定义,这个方法会被`runtime only`版本和`runtime compiler`版本中复用。

​		新定义的`$mount` 方法分析：

​		首先方法接收两个参数 `el` 和 `hydrating` ,方法内部对 `el` 进行判断和限制不能是 `document.body` 和 `document.documentElement` ，即不能是 `body`节点  和 `html节点`。

​		接下来判断 `render` 函数是否定义，没有定义就将 `el` 或 `template` 编译成 `render` 函数。

​		 ⚠️ 注意 ：这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 属性，最终都会转换成 render 方法。

​		从源码中可以看出编译调用了 `compileToFunctions` 方法实现。

​		最后通过调用缓存下来的原型方法 `mount.call(this, el, hydrating)` 挂载DOM。

​		源码目录：` src/platform/web/runtime/index.js `

```js
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

​		`$mount`方法接收两个参数 `el` 和 `hydrating` ，首先判断 `el` 存在并且在浏览器环境下调用 `query(el)` 获取到DOM对象，最后调用 `mountComponent(this, el, hydrating)` 方法挂载。

​		源码目录：` src/core/instance/lifecycle.js `

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 调用生命周期钩子beforeMount
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      // 首先vm._update和vm._render这两个方法是定义在Vue原型上的
      // 1.vm._render()把实例渲染成一个虚拟 Node
      // 2.vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // 调用生命周期钩子mounted
    callHook(vm, 'mounted')
  }
  return vm
}
```

​		`mountComponent` 方法的核心是通过实例化一个渲染 `watcher`，内部执行 `updateComponent`， 最终调用 `vm._update`更新 `DOM` 。

​		`Watcher` 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 `vm` 实例中的监测的数据发生变化的时候执行回调函数。

​		函数最后判断为根节点的时候设置 为 `true` ， 表示这个实例已经挂载了，同时执行 `mounted` 钩子函数。 这里注意 `vm.$vnode` 表示  `Vue` 实例的父虚拟` Node`，所以它为 `Null` 则表示当前是根` Vue` 的实例

​		`updateComponent` 方法的核心是 `vm._update` 和 `vm._render()` ：

​			-- 首先vm._update和vm._render这两个方法是定义在Vue原型上的；

​			-- vm._render()把实例渲染成一个虚拟 Node；

​			-- vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点



![vue实例化到挂载到dom流程图](https://github.com/lotosv2010/Vue-SourceCode-Analysis/blob/master/images/04/02%20vue%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%88%B0%E6%8C%82%E8%BD%BD%E5%88%B0dom%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

### 4. render

### 5. Virtual DOM

### 6. createElement

### 7. update

