## Vue数据驱动



---

[TOC]

---

​		传统的前端数据交互是用Ajax从服务端获取数据，然后操作DOM来改变视图；或者前端交互要改变数据时，又要再来一次上述步骤，而手动操作DOM是一个繁琐的过程且易出错。

​		什么是[数据驱动](https://segmentfault.com/a/1190000013276124)？

​		Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它让开发者省去了操作DOM的过程，只需要改变数据。Vue会通过Dircetives指令，对DOM做一层封装，当数据发生改变会通知指令去修改对应的DOM，数据驱动DOM变化，**DOM是数据的一种自然映射**。Vue还会对操作进行监听，当视图发生改变时，vue监听到这些变化，从而改变数据，这样就形成了数据的双向绑定。

​		接下来，我们会从源码角度来分析 Vue 是如何实现的，分析过程会以**主线代码为主**，重要的分支逻辑会放在之后单独分析。数据驱动还有一部分是数据更新驱动视图变化，这一块内容我们也会在之后的章节分析，这一章我们的目标是弄清楚模板和数据如何渲染成最终的 DOM。

### 1. [Vue构造函数](https://segmentfault.com/a/1190000014488094)

	#### 	1.1 new

​		首先我们带着一个问题去分析源码：**[new Vue](https://www.jianshu.com/p/ba840beb06c7)** **发生了什么？**

​		在 `JavaScript` 中 `new` 主要做了一下几件事：

​			(1)、创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型。

​			(2)、属性和方法被加入到 `this` 引用的对象中。

​			(3)、新创建的对象由 `this`  所引用，并且最后隐式的返回 `this` 。

```js
// Javascript的new关键字主要的作用是继承
// new一共经历4个阶段
// 1、创建一个空对象
var obj = new Object();

// 2、设置原型链
// 此时便建立了obj对象的原型链

obj._proto_ = Object.prototype;

// 3、让Func的this指向obj，并执行Func函数体
Object.call(obj);

// 4、判断Func的返回值类型
// 如果是值类型，返回obj；
// 如果是引用类型，返回这个引用类型的对象。
return typeof result === 'obj'? result : obj;
```

	#### 	1.2 Vue

​		源码目录：`src/core/instance/index.js`

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

​		可以看到Vue构造函数是一个很简洁的`function`工厂模式声明的一个构造函数， Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法。

### 2. _init(options)函数

#### 	2.1 _init源码分析

 	   源码目录：` src/core/instance/init.js `

```js
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    /* 
    * 测试代码性能
    * 参考：https://segmentfault.com/a/1190000014479800
    */
    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    // 避免被响应式的标识
    // 这里可以暂时理解新建observer实例就是让数据响应式
    vm._isVue = true
    // merge options
    // 有子组件时，options._isComponent才会为true
    if (options && options._isComponent) { // Vue实例是组件
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      /*
      * 优化内部组件实例化
      * 因为动态选项合并非常慢，而且
      * 内部组件选项需要特殊处理
      */
      // 优化components属性
      initInternalComponent(vm, options)
    } else {
      // 传入的options和vue自身的options进行合并
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* 
    * istanbul ignore else 
    * 参考：https://segmentfault.com/a/1190000014824359
    */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm) // 初始化一些和生命周期相关的内容
    initEvents(vm) // 初始化事件相关属性，当有父组件的方法绑定在子组件时候，供子组件调用
    initRender(vm) // 初始化渲染，添加slot属性
    callHook(vm, 'beforeCreate') // 调用beforeCreate钩子
    initInjections(vm) // resolve injections before data/props
    initState(vm) // 初始化数据，进行双向绑定 state/props
    initProvide(vm) // resolve provide after data/props, 注入provider的值到子组件中
    callHook(vm, 'created') // 调用created钩子

    /* istanbul ignore if */
    // 计算覆盖率时忽略下列代码
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el) // 把模板转换成render函数
    }
  }
```

​		Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始 化 data、props、computed、watcher 等等。

### 3. Vue实例挂载

#### 	3.1 新定义的`$mount`

​		在`_init()`函数的最后，执行了`vm.$mount()`。vm代表的是当前vue实例也就是构造函数被调用后的`this`指向。

​		`$mount`是何时在vue上声明的呢？这次并不是在上边的初始化函数中完成声明的。因为 $mount 这个方法的实现是和平台、构建方式都相关，所以在不同构建入口文件中有不同的定义。如：`src/platform/web/entry-runtime-with-compiler.js` 、`src/platform/web/runtime/index.js` 、`src/platform/weex/runtime/index.js` 中都有定义。

​		在这里我门以compiler版本为例，进行源码分析。

​		**[vue版本说明](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释)**

​		源码目录：` src/platform/web/entry-runtime-with-compiler.js `

```js

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      // 模板编译成render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

​		首先缓存原型上的方法 `const mount = Vue.prototype.$mount`, 然后重新定义该方法。原型上声明的 `$mount`方法在 `src/platform/web/runtime/index.js` 中定义,这个方法会被`runtime only`版本和`runtime compiler`版本中复用。

​		新定义的`$mount` 方法分析：

​		首先方法接收两个参数 `el` 和 `hydrating` ,方法内部对 `el` 进行判断和限制不能是 `document.body` 和 `document.documentElement` ，即不能是 `body`节点  和 `html节点`。

​		接下来判断 `render` 函数是否定义，没有定义就将 `el` 或 `template` 编译成 `render` 函数。

​		 ⚠️ 注意 ：这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 属性，最终都会转换成 render 方法。

​		从源码中可以看出编译调用了 `compileToFunctions` 方法实现。

​		最后通过调用缓存下来的原型方法 `mount.call(this, el, hydrating)` 挂载DOM。

#### 	3.2 `Vue`原型上的`$mount`

​		源码目录：` src/platform/web/runtime/index.js `

```js
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

​		`$mount`方法接收两个参数 `el` 和 `hydrating` ，首先判断 `el` 存在并且在浏览器环境下调用 `query(el)` 获取到DOM对象，最后调用 `mountComponent(this, el, hydrating)` 方法挂载。

#### 	3.3 `mountComponent`方法

​		源码目录：` src/core/instance/lifecycle.js `

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  // 调用生命周期钩子beforeMount
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      // 首先vm._update和vm._render这两个方法是定义在Vue原型上的
      // 1.vm._render()把实例渲染成一个虚拟 Node
      // 2.vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 渲染watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用生命周期钩子beforeUpdate
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    // 调用生命周期钩子mounted
    callHook(vm, 'mounted')
  }
  return vm
}
```

​		`mountComponent` 方法的核心是通过实例化一个渲染 `watcher`，内部执行 `updateComponent`， 最终调用 `vm._update`更新 `DOM` 。

​		`Watcher` 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 `vm` 实例中的监测的数据发生变化的时候执行回调函数。

​		函数最后判断为根节点的时候设置 为 `true` ， 表示这个实例已经挂载了，同时执行 `mounted` 钩子函数。 这里注意 `vm.$vnode` 表示  `Vue` 实例的父虚拟` Node`，所以它为 `Null` 则表示当前是根` Vue` 的实例

​		`updateComponent` 方法的核心是 `vm._update` 和 `vm._render()` ：

​			-- 首先vm._update和vm._render这两个方法是定义在Vue原型上的；

​			-- vm._render()把实例渲染成一个虚拟 Node；

​			-- vm._update更新 DOM，内部调用 vm.__patch__转换成真正的 DOM 节点

### 4. render

#### 	4.1 `_render`

​		`Vue` 的 `_render` 方法是用来把实例渲染成一个虚拟 `Node`。是在 `renderMixin(Vue)` 执行时声明的。它的定义在 `src/core/instance/render.js` 文件中。

​		源码目录：` src/core/instance/render.js `

```js
    Vue.prototype._render = function (): VNode {
    // this是Vue实例
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      // 核心方法，返回一个vnode
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = null
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```

​		这段代码中的核心方法是 `vnode = render.call(vm._renderProxy, vm.$createElement)` 。

​		`Vue` 推荐在绝大多数情况下使用模板来创建你的 `HTML`。然而在一些场景中，你真的需要 `JavaScript` 的完全编程的能力。这时你可以用**渲染函数**，它比模板更接近编译器。[`render详情查看这里`](https://cn.vuejs.org/v2/guide/render-function.html)

​		`render` 函数最终 执行的是下面这段代码，`with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(msg))])}` ，其中 `_c(...)` 实质是 `createElement` 方法就是 `vm.$createElement` 方法。

#### 	4.2 `initRender`

​		源码目录：` src/core/instance/render.js `

```js
export function initRender (vm: Component) {
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // the placeholder node in parent tree
  const renderContext = parentVnode && parentVnode.context
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  vm.$scopedSlots = emptyObject
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  // 模板编译成的 render 函数使用
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  // 用户手写 render 方法使用
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  const parentData = parentVnode && parentVnode.data

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)
    }, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)
    }, true)
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)
  }
}

```

​		`vm._c` : 模板编译成的 `render ` 函数使用;

​		`vm.$createElement` : 用户手写 `render` 方法使用;

​		这俩个方法支持的参数相同，并且内部都调用了 `createElement` 方法。

### 5. Virtual DOM

#### 	5.1 什么是 `Virtual Dom`？

​		`Virtual Dom` 可以看做一棵模拟了 `DOM` 树的 `JavaScript` 树，其主要是通过 `vnode` ,实现一个无状态的组件，当组件状态发生更新时，然后触发 `Virtual Dom` 数据的变化，然后通过 `Virtual Dom` 和真实 `DOM` 的比对，再对真实`DOM ` 更新。可以简单认为 `Virtual Dom` 是真实 `DOM` 的缓存。

	#### 	5.2 为什么用 `Virtual Dom`？

​		我们知道，当我们希望实现一个具有复杂状态的界面时，如果我们在每个可能发生变化的组件上都绑定事件，绑定字段数据，那么很快由于状态太多，我们需要维护的事件和字段将会越来越多，代码也会越来越复杂，于是，我们想我们可不可以将视图和状态分开来，只要视图发生变化，对应状态也发生变化，然后状态变化，我们再重绘整个视图就好了。

​		这样的想法虽好，但是代价太高了，于是我们又想，能不能只更新状态发生变化的视图？于是 `Virtual Dom` 应运而生，状态变化先反馈到 `Virtual Dom` 上，`Virtual Dom` 在找到最小更新视图，最后批量更新到真实 `DOM` 上，从而达到性能的提升。

​		除此之外，从移植性上看，`Virtual Dom` 还对真实 `DOM` 做了一次抽象，这意味着 `Virtual Dom` 对应的可以不是浏览器的 `DOM`，而是不同设备的组件，极大的方便了多平台的使用。如果是要实现前后端同构直出方案，使用 `Virtual Dom` 的框架实现起来是比较简单的，因为在服务端的 `Virtual Dom` 跟浏览器 `DOM` 接口并没有绑定关系。

​		`Virtual DOM`  简单的说就是一颗树，一颗以 `javaScript` 对象 `（VNode）` 作为基础的树，用对象的属性来描述节点，因此这个对象至少包含标签名 `（tag）` 、属性 `（attrs）` 、和 子元素对象 `（chuildren）`。

　　`Virtual DOM`  的最终目的是将虚拟的节点渲染到视图上，其实它主要做了两件事：

​			(1)、提供与真实 `DOM` 节点对应的虚拟节点` VNode`；

​			(2)、将虚拟节点 `VNode` 和旧虚拟节点` (oldVNode)` 进行对比，然后更新视图；

　　`Virtual DOM`  的优势：

　　　　(1)、具备跨平台的优势；

　　　　(2)、操作` DOM` 慢，`js` 运行的效率高；`vue`  将 `DOM` 对比放在 `js` 层，提高效率，`Virtual DOM` 本质上其实就是 `js`  和 `dom` 之间的一个缓存，通过` patching` 算法计算出真正需要更新的节点，最大限度的减少 `DOM` 操作；

　　　　(3)、提升渲染的性能；`DOM`操作的减少，可以避免更多的回流和重绘等，更加高效的提高性能。

#### 	5.3 `Virtual DOM` 和 `DOM`对比

​		下面看一下真实 `DOM` 的属性和`Virtual DOM`的定义：

```js
// 真实 DOM 所有属性
/*
align title lang translate dir hidden accessKey draggable spellcheck autocapitalize contentEditable isContentEditable inputMode offsetParent offsetTop offsetLeft offsetWidth offsetHeight style innerText outerText oncopy oncut onpaste onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror onfocus onformdata oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting onwheel onauxclick ongotpointercapture onlostpointercapture onpointerdown onpointermove onpointerup onpointercancel onpointerover onpointerout onpointerenter onpointerleave onselectstart onselectionchange onanimationend onanimationiteration onanimationstart ontransitionend dataset nonce autofocus tabIndex click attachInternals focus blur enterKeyHint onpointerrawupdate namespaceURI prefix localName tagName id className classList slot attributes shadowRoot part assignedSlot innerHTML outerHTML scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight attributeStyleMap onbeforecopy onbeforecut onbeforepaste onsearch elementTiming previousElementSibling nextElementSibling children firstElementChild lastElementChild childElementCount onfullscreenchange onfullscreenerror onwebkitfullscreenchange onwebkitfullscreenerror hasAttributes getAttributeNames getAttribute getAttributeNS setAttribute setAttributeNS removeAttribute removeAttributeNS toggleAttribute hasAttribute hasAttributeNS getAttributeNode getAttributeNodeNS setAttributeNode setAttributeNodeNS removeAttributeNode attachShadow closest matches webkitMatchesSelector getElementsByTagName getElementsByTagNameNS getElementsByClassName insertAdjacentElement insertAdjacentText setPointerCapture releasePointerCapture hasPointerCapture insertAdjacentHTML requestPointerLock getClientRects getBoundingClientRect scrollIntoView scroll scrollTo scrollBy scrollIntoViewIfNeeded animate computedStyleMap before after replaceWith remove prepend append querySelector querySelectorAll requestFullscreen webkitRequestFullScreen webkitRequestFullscreen ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE DOCUMENT_POSITION_DISCONNECTED DOCUMENT_POSITION_PRECEDING DOCUMENT_POSITION_FOLLOWING DOCUMENT_POSITION_CONTAINS DOCUMENT_POSITION_CONTAINED_BY DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC nodeType nodeName baseURI isConnected ownerDocument parentNode parentElement childNodes firstChild lastChild previousSibling nextSibling nodeValue textContent hasChildNodes getRootNode normalize cloneNode isEqualNode isSameNode compareDocumentPosition contains lookupPrefix lookupNamespaceURI isDefaultNamespace insertBefore appendChild replaceChild removeChild addEventListener removeEventListener dispatchEvent 
*/
```

​		源码目录：` src/core/vdom/vnode.js`

```js
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  get child (): Component | void {
    return this.componentInstance
  }
}

```

​		实际上 `Vue.js` 中 Virtual `DOM` 是借鉴了一个开源库[ `snabbdom`](https://github.com/snabbdom/snabbdom) 的实现，然后加入了一些 `Vue.js` 特色的东⻄。我建议大家如果想深入了解 `Vue.js` 的 `Virtual DOM` 前不妨先阅读这个库的源码，因为它更加简单和纯粹。

​		其实 `VNode` 是对真实 `DOM` 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子 节点、键值等，其它属性都是都是用来扩展 `VNode` 的灵活性以及实现一些特殊` feature` 的。由于 `VNode` 只是用来映射到真实 `DOM` 的渲染，不需要包含操作` DOM` 的方法，因此它是非常轻量和简单的。

​		`Virtual DOM` 除了它的数据结构的定义，映射到真实的 `DOM` 实际上要经历 `VNode` 的 `create`、`diff`、 `patch` 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的。

​		主要涉及的几个重要概念：渲染函数、`VNode`虚拟节点、`patch`(`patching`算法)；

　　　　渲染函数：主要是用来生成` virtual DOM` 的；`vue` 虽然推荐使用 `template` 来构建页面，但是其实也是支持直接写渲染函数的；

　　　　`VNode`虚拟节点：它是节点描述，可以代表一个真实的`DOM`，最终真实的`DOM`就是通过 `createElement` 将`VNode` 渲染成真实的`DOM`的；

　　　　`patch(也叫patching算法)`：它是虚拟`DOM`最核心的部分，`VNode`最终就是经过这个算法成为真实的`DOM`的，这个过程是对比新旧节点之间的不同，然后根据对比结果找出需要更新的节点进行更新；

### 6. createElement

### 7. update

### 8. 总结

![vue实例化到挂载到dom流程图](https://github.com/lotosv2010/Vue-SourceCode-Analysis/blob/master/images/04/02%20vue%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%88%B0%E6%8C%82%E8%BD%BD%E5%88%B0dom%E6%B5%81%E7%A8%8B%E5%9B%BE.png)