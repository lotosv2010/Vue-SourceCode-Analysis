## 编译原理



---

[TOC]

---

​	模板到真实 `DOM` 渲染的过程，中间有一个环节是把模板编译成 `render` 函数，这个过程我们把它称作编译。

​	`Vue.js` 提供了 `2` 个版本，一个是 `Runtime + Compile`r 的，一个是 `Runtime only` 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 `webpack` 的 `vue-loader` 事 先把模板编译成 `render` 函数。

### 1. 编译入口

​	当我们使用 `Runtime + Compile`r 的 `Vue.js`，它对 `$mount` 函数的定义。

​	源码目录：`src/platforms/web/entry-runtime-with-compiler.js`

```js
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      // 模板编译成render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

​	这个函数执行编译的主要代码是：

```js
// 模板编译成render函数
const { render, staticRenderFns } = compileToFunctions(template, {
  outputSourceRange: process.env.NODE_ENV !== 'production',
  shouldDecodeNewlines,
  shouldDecodeNewlinesForHref,
  delimiters: options.delimiters,
  comments: options.comments
}, this)
options.render = render
options.staticRenderFns = staticRenderFns
```

​	`compileToFunctions` 方法就是把模板 `template` 编译生成 `render` 以及 `staticRenderFns`。

​	源码目录：`src/platforms/web/compiler/index.js`

```js
/* @flow */

import { baseOptions } from './options'
import { createCompiler } from 'compiler/index'

const { compile, compileToFunctions } = createCompiler(baseOptions)

export { compile, compileToFunctions }
```

​	从上面的代码我们可以看出，`compileToFunctions` 方法实际上是执行的 `createCompiler(baseOptions)` 方法，该方法接收一个编译配置参数。

​	源码目录：`src/compiler/index.js`

```js
/* @flow */

import { parse } from './parser/index'
import { optimize } from './optimizer'
import { generate } from './codegen/index'
import { createCompilerCreator } from './create-compiler'

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

​	从上面的代码我们可以看出，`createCompiler` 方法实际上是通过调用 `createCompilerCreator` 方法返回的，该方法传入的参数是一个函数，真正的编译过程都是在这个 `baseCompile` 函数中执行的。

​	源码目录：`src/compiler/create-compiler.js`

```js
/* @flow */

import { extend } from 'shared/util'
import { detectErrors } from './error-detector'
import { createCompileToFunctionFn } from './to-function'

export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []

      let warn = (msg, range, tip) => {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
          // $flow-disable-line
          const leadingSpaceLength = template.match(/^\s*/)[0].length

          warn = (msg, range, tip) => {
            const data: WarningMessage = { msg }
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength
              }
            }
            (tip ? tips : errors).push(data)
          }
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        // copy other options
        for (const key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key]
          }
        }
      }

      finalOptions.warn = warn

      const compiled = baseCompile(template.trim(), finalOptions)
      if (process.env.NODE_ENV !== 'production') {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

```

​	从上面的代码我们可以看出，`createCompiler` 的函数，它接收一个 `baseOptions` 的参数，返回的是一个对象，包括 `compile` 方法属性和 `compileToFunctions` 属性，这个`compileToFunctions` 对应的就是 `$mount` 函数调用的 `compileToFunctions` 方法，它是调用 `createCompileToFunctionFn` 方法的返回值。

​	源码目录：`src/compiler/to-function.js`

```js
/* @flow */

import { noop, extend } from 'shared/util'
import { warn as baseWarn, tip } from 'core/util/debug'
import { generateCodeFrame } from './codeframe'

type CompiledFunctionResult = {
  render: Function;
  staticRenderFns: Array<Function>;
};

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}

export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1')
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          )
        }
      }
    }

    // check cache
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // compile
    const compiled = compile(template, options)

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(e => {
            warn(
              `Error compiling template:\n\n${e.msg}\n\n` +
              generateCodeFrame(template, e.start, e.end),
              vm
            )
          })
        } else {
          warn(
            `Error compiling template:\n\n${template}\n\n` +
            compiled.errors.map(e => `- ${e}`).join('\n') + '\n',
            vm
          )
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(e => tip(e.msg, vm))
        } else {
          compiled.tips.forEach(msg => tip(msg, vm))
        }
      }
    }

    // turn code into functions
    const res = {}
    const fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          `Failed to generate render function:\n\n` +
          fnGenErrors.map(({ err, code }) => `${err.toString()} in\n\n${code}\n`).join('\n'),
          vm
        )
      }
    }

    return (cache[key] = res)
  }
}
```

​	至此我们总算找到了 `compileToFunctions` 的最终定义，它接收 3 个参数、编译模板 `template` ，编译配置 `options` 和 `Vue` 实例 `vm` 。核心的编译过程就一行代码:

```js
const compiled = compile(template, options)
```

​	`compile` 函数在执行 `createCompileToFunctionFn` 的时候作为参数传入，它是 `createCompiler` 函数中定义的 `compile` 函数。

​	源码目录：`src/compiler/create-compiler.js`

```js
function compile (
template: string,
 options?: CompilerOptions
): CompiledResult {
  const finalOptions = Object.create(baseOptions)
  const errors = []
  const tips = []

  let warn = (msg, range, tip) => {
    (tip ? tips : errors).push(msg)
  }

  if (options) {
    if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
      // $flow-disable-line
      const leadingSpaceLength = template.match(/^\s*/)[0].length

      warn = (msg, range, tip) => {
        const data: WarningMessage = { msg }
        if (range) {
          if (range.start != null) {
            data.start = range.start + leadingSpaceLength
          }
          if (range.end != null) {
            data.end = range.end + leadingSpaceLength
          }
        }
        (tip ? tips : errors).push(data)
      }
    }
    // merge custom modules
    if (options.modules) {
      finalOptions.modules =
        (baseOptions.modules || []).concat(options.modules)
    }
    // merge custom directives
    if (options.directives) {
      finalOptions.directives = extend(
        Object.create(baseOptions.directives || null),
        options.directives
      )
    }
    // copy other options
    for (const key in options) {
      if (key !== 'modules' && key !== 'directives') {
        finalOptions[key] = options[key]
      }
    }
  }

  finalOptions.warn = warn

  const compiled = baseCompile(template.trim(), finalOptions)
  if (process.env.NODE_ENV !== 'production') {
    detectErrors(compiled.ast, warn)
  }
  compiled.errors = errors
  compiled.tips = tips
  return compiled
}
```

​	`compile` 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码:

```js
const compiled = baseCompile(template.trim(), finalOptions)
```

​	`baseCompile` 在执行` createCompilerCreator ` 方法时作为参数传入，如下:

​	源码目录：`src/compiler/index.js`

```js
function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
```

​	所以编译的入口我们终于找到了，它主要就是执行了如下几个逻辑:

​		(1) 解析模板字符串生成 AST

```js
const ast = parse(template.trim(), options)
```

​		(2) 优化语法树

```js
optimize(ast, options)
```

​		(3) 生成代码

```js
const code = generate(ast, options)
```

​	编译入口逻辑之所以这么绕，是因为 `Vue.js` 在不同的平台下都会有编译的过程，因此编译过程中的依赖的配置 `baseOptions` 会有所不同。而编译过程会多次执行，但这同一个平台下每一次的编译过程配置又是相同的，为了不让这些配置在每次编译过程都通过参数传入，`Vue.js` 利用了函数柯里化的技巧 很好的实现了 的参数保留。同样，`Vue.js` 也是利用函数柯里化技巧把基础的编译过程函数抽出来，通过 的方式把真正编译的过程和其它逻辑如对编译配置处理、缓存处理等剥离开，这样的设计还是非常巧妙的。

### 2. `parse`

​	编译过程首先就是对模板做解析，生成 `AST`，它是一种抽象语法树，是对源代码的抽象语法结构的树 状表现形式。在很多编译技术中，如` babel` 编译` ES6` 的代码都会先生成 `AST`。

​	这个过程是比较复杂的，它会用到大量正则表达式对字符串解析，如果对正则不是很了解，建议先去补习正则表达式的知识。为了直观地演示 `parse` 的过程，我们先来看一个例子:

```html
<ul :class="bindCls" class="list" v-if="isShow">
	<li v-for="(item,index) in data" @click="clickItem(index)">{{item}}:{{index}}</li> 
</ul>
```

​	经过 `parse` 过程后，生成的 `AST` 如下:

```js
ast = {
  'type': 1,
  'tag': 'ul',
  'attrsList': [],
  'attrsMap': {
		':class': 'bindCls', 
    'class': 'list', 
    'v-if': 'isShow'
  },
  'if': 'isShow',
  'ifConditions': [{
    'exp': 'isShow',
    'block': // ul ast element
  }],
  'parent': undefined,
  'plain': false,
  'staticClass': 'list',
  'classBinding': 'bindCls',
  'children': [{
    'type': 1,
    'tag': 'li',
    'attrsList': [{
      'name': '@click',
      'value': 'clickItem(index)'
    }],
		'attrsMap': {
			'@click': 'clickItem(index)', 
      'v-for': '(item,index) in data'
     },
    'parent': // ul ast element
    'plain': false,
    'events': {
  		'click': {
  			'value': 'clickItem(index)'
			}
		},
    'hasBindings': true,
    'for': 'data',
    'alias': 'item',
    'iterator1': 'index',
    'children': [
			'type': 2,
			'expression': '_s(item)+":"+_s(index)',
      'text': '{{item}}:{{index}}', 
      'tokens': [
        {'@binding':'item'},
        ':',
        {'@binding':'index'}
			]
    ]
	}] 
}
```

​	可以看到，生成的 `AST` 是一个树状结构，每一个节点都是一个 `ast element`，除了它自身的一些属性，还维护了它的父子关系，如 `parent` 指向它的父节点，`children` 指向它的所有子节点。先对 `AST` 有一些直观的印象，那么接下来我们来分析一下这个 `AST` 是如何得到的。

#### 	2.1 整体流程

​		`parse` 的定义，下面代码为精简后的伪代码。

​		源码目录：`src/compiler/parser/index.js`

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  getFnsAndConfigFromOptions(options)

  function warnOnce (msg, range) {
    // ...
  }

  function closeElement (element) {
    // ...
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    // ...
  }

  function checkRootConstraints (el) {
    // ...
  }

  parseHTML(template, {
    // options ...
    start (tag, attrs, unary, start, end) {
      // ...
      let element: ASTElement = createASTElement(tag, attrs, currentParent)
       // ...
      processElement(element)
      treeManagement()
      // ...
    },

    end (tag, start, end) {
      // ...
      treeManagement()
      closeElement(element)
    },

    chars (text: string, start: number, end: number) {
      // ...
      handleText()
      createChildrenASTOfText()
    },
    comment (text: string, start, end) {
      // ...
      createChildrenASTOfComment()
    }
  })
  return root
}
```

#### 	2.2 从 `options` 中获取方法和配置

​		对应伪代码：

```js
getFnsAndConfigFromOptions(options)
```

​		`parse` 函数的输入是 `template` 和 `options` ，输出是 `AST` 的根节点。 `template` 就是我们的模板字符串，而 实际上是和平台相关的一些配置。

​		源码目录：`src/platforms/web/compiler/options.js`

```js
/* @flow */

import {
  isPreTag,
  mustUseProp,
  isReservedTag,
  getTagNamespace
} from '../util/index'

import modules from './modules/index'
import directives from './directives/index'
import { genStaticKeys } from 'shared/util'
import { isUnaryTag, canBeLeftOpenTag } from './util'

export const baseOptions: CompilerOptions = {
  expectHTML: true,
  modules,
  directives,
  isPreTag,
  isUnaryTag,
  mustUseProp,
  canBeLeftOpenTag,
  isReservedTag,
  getTagNamespace,
  staticKeys: genStaticKeys(modules)
}
```

​		这些属性和方法之所以放到 `platforms` 目录下是因为它们在不同的平台(`web` 和 `weex`)的实现是不同的。

​		我们用伪代码 `getFnsAndConfigFromOptions` 表示了这一过程，它的实际代码如下:

​		源码目录：`src/compiler/parser/index.js`

```js

/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  warn = options.warn || baseWarn

  platformIsPreTag = options.isPreTag || no
  platformMustUseProp = options.mustUseProp || no
  platformGetTagNamespace = options.getTagNamespace || no
  const isReservedTag = options.isReservedTag || no
  maybeComponent = (el: ASTElement) => !!el.component || !isReservedTag(el.tag)

  transforms = pluckModuleFunction(options.modules, 'transformNode')
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode')
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode')

  delimiters = options.delimiters

	// ...
}
```

​		这些方法和配置都是后续解析时候需要的。

#### 	2.3 解析 `HTML` 模板

​		对应伪代码:

```
 parseHTML(template, options)
```

​		对于 模板的解析主要是通过 parseHTML 函数。

​		源码目录：`src/compiler/parser/html-parser.js`

```js
export function parseHTML (html, options) {
  let lastTag
  while (html) {
		if (!lastTag || !isPlainTextElement(lastTag)){ 
      let textEnd = html.indexOf('<')
			if (textEnd === 0) {
         if(matchComment) {
           advance(commentLength)
           continue
         }
         if(matchDoctype) {
           advance(doctypeLength)
					 continue
         }
         if(matchEndTag) {
           advance(endTagLength)
           parseEndTag()
           continue
         }
         if(matchStartTag) {
           parseStartTag()
           handleStartTag()
           continue
				 }
      }
      handleText()
      advance(textLength)
    } else {
       handlePlainTextElement()
       parseEndTag()
    }
	}
}
```

​			由于 `parseHTML` 的逻辑也非常复杂，因此我也用了伪代码的方式表达，整体来说它的逻辑就是循环解析 `template`，用正则做各种匹配，对于不同情况分别进行不同的处理，直到整个 `template` 被解析完毕。 在匹配的过程中会利用 `advance` 函数不断前进整个模板字符串，直到字符串末尾。

​			源码目录：`src/compiler/parser/html-parser.js`

```js
export function parseHTML (html, options) {
  // ...
  function advance (n) {
    index += n
    html = html.substring(n)
  }
  // ...
}
```

​		为了更加直观地说明 `advance` 的作用，可以通过一副图表示:

![](https://raw.githubusercontent.com/lotosv2010/Vue-SourceCode-Analysis/master/images/07/01-advance.png)

​		调用 `advance` 函数:

```js
advance(4)
```

​		得到结果:

![](https://raw.githubusercontent.com/lotosv2010/Vue-SourceCode-Analysis/master/images/07/01-advance2.png)

​		匹配的过程中主要利用了正则表达式，如下:

​		源码目录：`src/compiler/parser/html-parser.js`

```js
// Regular Expressions for parsing tags and attributes
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
const dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const startTagOpen = new RegExp(`^<${qnameCapture}`)
const startTagClose = /^\s*(\/?)>/
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)
const doctype = /^<!DOCTYPE [^>]+>/i
// #7298: escape - to avoid being passed as HTML comment when inlined in page
const comment = /^<!\--/
const conditionalComment = /^<!\[/
```

​		通过这些正则表达式，我们可以匹配注释节点、文档类型节点、开始闭合标签等。

			##### 			2.3.1 注释节点、文档类型节点

​				对于注释节点和文档类型节点的匹配，如果匹配到我们仅仅做的是做前进即可。

​				对于注释和条件注释节点，前进至它们的末尾位置;对于文档类型节点，则前进它自身⻓度的距离。

​				源码目录：`src/compiler/parser/html-parser.js`

```js
// Comment:
if (comment.test(html)) {
  const commentEnd = html.indexOf('-->')

  if (commentEnd >= 0) {
    if (options.shouldKeepComment) {
      options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3)
    }
    advance(commentEnd + 3)
    continue
  }
}
// http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
if (conditionalComment.test(html)) {
  const conditionalEnd = html.indexOf(']>')

  if (conditionalEnd >= 0) {
    advance(conditionalEnd + 2)
    continue
  }
}

// Doctype:
const doctypeMatch = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}

```

			##### 			2.3.2 开始标签

​				源码目录：`src/compiler/parser/html-parser.js`

```js
// Start tag:
const startTagMatch = parseStartTag()
if (startTagMatch) {
  handleStartTag(startTagMatch)
  if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
    advance(1)
  }
  continue
}
```

​				首先通过 `parseStartTag` 解析开始标签:

​				源码目录：`src/compiler/parser/html-parser.js`

```js
function parseStartTag () {
  const start = html.match(startTagOpen)
  if (start) {
    const match = {
      tagName: start[1],
      attrs: [],
      start: index
    }
    advance(start[0].length)
    let end, attr
    while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
      attr.start = index
      advance(attr[0].length)
      attr.end = index
      match.attrs.push(attr)
    }
    if (end) {
      match.unarySlash = end[1]
      advance(end[0].length)
      match.end = index
      return match
    }
  }
}
```

​				对于开始标签，除了标签名之外，还有一些标签相关的属性。函数先通过正则表达式 `startTagOpen` 匹配到开始标签，然后定义了 `match` 对象，接着循环去匹配开始标签中的属性并添加到`match.attrs` 中，直到匹配的开始标签的闭合符结束。如果匹配到闭合符，则获取一元斜线符，前进到闭合符尾，并把当前索引赋值给 `match.end` 。

​				`parseStartTag` 对开始标签解析拿到 `match` 后，紧接着会执行` handleStartTag` 对` matc`h 做处理:

​				源码目录：`src/compiler/parser/html-parser.js`

```js
function handleStartTag (match) {
    const tagName = match.tagName
    const unarySlash = match.unarySlash

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag)
      }
      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName)
      }
    }

    const unary = isUnaryTag(tagName) || !!unarySlash

    const l = match.attrs.length
    const attrs = new Array(l)
    for (let i = 0; i < l; i++) {
      const args = match.attrs[i]
      const value = args[3] || args[4] || args[5] || ''
      const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      }
      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length
        attrs[i].end = args.end
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end })
      lastTag = tagName
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end)
    }
  }
```

​				`handleStartTag` 的核心逻辑很简单，先判断开始标签是否是一元标签，类似 `<img>`、`<br/>` 这 样，接着对 `match.attrs` 遍历并做了一些处理，最后判断如果非一元标签，则往 `stack` 里 `push` 一个对象，并且把 `getName` 赋值给 `lastTag` 。至于 `stack` 的作用，稍后我会介绍。

​				最后调用了 `options.start` 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。

			##### 			2.3.3 闭合标签

​				源码目录：`src/compiler/parser/html-parser.js`

```js
// End tag:
const endTagMatch = html.match(endTag)
if (endTagMatch) {
  const curIndex = index
  advance(endTagMatch[0].length)
  parseEndTag(endTagMatch[1], curIndex, index)
  continue
}
```

​				先通过正则 `endTag` 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 `parseEndTag` 方法对闭合标签做解析。

​				源码目录：`src/compiler/parser/html-parser.js`

```js
function parseEndTag (tagName, start, end) {
    let pos, lowerCasedTagName
    if (start == null) start = index
    if (end == null) end = index

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase()
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (let i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            `tag <${stack[i].tag}> has no matching end tag.`,
            { start: stack[i].start, end: stack[i].end }
          )
        }
        if (options.end) {
          options.end(stack[i].tag, start, end)
        }
      }

      // Remove the open elements from the stack
      stack.length = pos
      lastTag = pos && stack[pos - 1].tag
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end)
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end)
      }
      if (options.end) {
        options.end(tagName, start, end)
      }
    }
  }
```

​				`parseEndTag` 的核心逻辑很简单，在介绍之前我们回顾一下在执行 `handleStartTag` 的时候，对于非一元标签(有 `endTag`)我们都把它构造成一个对象压入到 `stack` 中，如图所示:

![](https://raw.githubusercontent.com/lotosv2010/Vue-SourceCode-Analysis/master/images/07/02-parseEndTag.png)

​				那么对于闭合标签的解析，就是倒序 `stack` ，找到第一个和当前 `endTag` 匹配的元素。如果是正常的标签匹配，那么 `stack` 的最后一个元素应该和当前 匹配，但是考虑到如下错误情况:

```html
<div><span></div>
```

​				这个时候当 `endTag` 为 `</div>` 的时候，从 `stack` 尾部找到的标签是 `<span> `，就不能匹配，因此这种情况会报警告。匹配后把栈到 `pos` 位置的都弹出，并从 `stack` 尾部拿到 `lastTag` 。

​				最后调用了 `options.end` 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。

			##### 			2.3.4 文本

​				源码目录：`src/compiler/parser/html-parser.js`

```js
let text, rest, next
if (textEnd >= 0) {
  rest = html.slice(textEnd)
  while (
    !endTag.test(rest) &&
    !startTagOpen.test(rest) &&
    !comment.test(rest) &&
    !conditionalComment.test(rest)
  ) {
    // < in plain text, be forgiving and treat it as text
    next = rest.indexOf('<', 1)
    if (next < 0) break
    textEnd += next
    rest = html.slice(textEnd)
  }
  text = html.substring(0, textEnd)
}

if (textEnd < 0) {
  text = html
}

if (text) {
  advance(text.length)
}

if (options.chars && text) {
  options.chars(text, index - text.length, index)
}
```

​				源码目录：`src/compiler/parser/html-parser.js`

​				接下来判断 `textEnd` 是否大于等于 `0` 的，满足则说明到从当前位置到 `textEnd` 位置都是文本，并且如果 `<` 是纯文本中的字符，就继续找到真正的文本结束的位置，然后前进到结束的位置。

​				再继续判断 `textEnd` 小于 `0` 的情况，则说明整个 `template` 解析完毕了，把剩余的 `html` 都赋值给了 `text` 。

​				最后调用了 `options.chars` 回调函数，并传 `text` 参数，这个回调函数的作用稍后我会详细介绍。 因此，在循环解析整个` template` 的过程中，会根据不同的情况，去执行不同的回调函数，下面我们来看看这些回调函数的作用。

#### 	2.4 处理开始标签

​		对应伪代码:

```js
start (tag, attrs, unary) {
  let element = createASTElement(tag, attrs)
  processElement(element)
  treeManagement()
}
```

​		当解析到开始标签的时候，最后会执行 `start` 回调函数，函数主要就做 3 件事情，创建 `AST` 元素， 处理 `AST` 元素，`AST` 树管理。下面我们来分别来看这几个过程。

			##### 			2.4.1  创建 `AST` 元素

​				源码目录：`src/compiler/parser/index.js`

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  parseHTML(template, {
    //...
    start (tag, attrs, unary, start, end) {
      // check namespace.
      // inherit parent ns if there is one
      const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag)

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs)
      }

      let element: ASTElement = createASTElement(tag, attrs, currentParent)
      if (ns) {
        element.ns = ns
      }
			// ...
  	}
	})
  return root
}

export function createASTElement (
  tag: string,
  attrs: Array<ASTAttr>,
  parent: ASTElement | void
): ASTElement {
  return {
    type: 1,
    tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent,
    children: []
  }
}

```

​				通过 `createASTElement `方法去创建一个 `AST` 元素，并添加了 `namespace`。可以看到，每一个 `AST` 元素就是一个普通的 `JavaScrip`t 对象，其中，` type` 表示 `AST` 元素类型， `tag` 表示标签名，`attrsList` 表示属性列表，`attrsMap` 表示属性映射表， `parent` 表示父的 `AST` 元素，`children` 表示子 `AST` 元素集合。

			##### 			2.4.2 处理 `AST` 元素

​				源码目录：`src/compiler/parser/index.js`

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  parseHTML(template, {
    //...
    start (tag, attrs, unary, start, end) {
			// ...
    	if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true
        process.env.NODE_ENV !== 'production' && warn(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          `<${tag}>` + ', as they will not be parsed.',
          { start: element.start }
        )
      }

      // apply pre-transforms
      for (let i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element
      }

      if (!inVPre) {
        processPre(element)
        if (element.pre) {
          inVPre = true
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true
      }
      if (inVPre) {
        processRawAttrs(element)
      } else if (!element.processed) {
        // structural directives
        processFor(element)
        processIf(element)
        processOnce(element)
      }
  	}
	})
  return root
}

```

​				首先是对模块 `preTransforms` 的调用，其实所有模块的 `preTransforms`、`transforms` 和 `postTransforms` 的定义都在 `src/platforms/web/compiler/modules` 目录中，这部分暂时不做分析，之后会结合具体的例子分析。

​				接着判断 `element` 是否包含各种指令通过 `processXXX` 做相应 的处理，处理的结果就是扩展 `AST` 元素的属性。这里我并不会一一介绍所有的指令处理，而是结合我们当前的例子，我们来看一下` processFor` 和` processIf` :

​				源码目录：`src/compiler/parser/index.js`

```js
export function processFor (el: ASTElement) {
  let exp
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    const res = parseFor(exp)
    if (res) {
      extend(el, res)
    } else if (process.env.NODE_ENV !== 'production') {
      warn(
        `Invalid v-for expression: ${exp}`,
        el.rawAttrsMap['v-for']
      )
    }
  }
}

export const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
export const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
const stripParensRE = /^\(|\)$/g

export function parseFor (exp: string): ?ForParseResult {
  const inMatch = exp.match(forAliasRE)
  if (!inMatch) return
  const res = {}
  res.for = inMatch[2].trim()
  const alias = inMatch[1].trim().replace(stripParensRE, '')
  const iteratorMatch = alias.match(forIteratorRE)
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim()
    res.iterator1 = iteratorMatch[1].trim()
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim()
    }
  } else {
    res.alias = alias
  }
  return res
}
```

​				`processFor` 就是从元素中拿到 `v-for` 指令的内容，然后分别解析出 `for`、 `alias`、 `iterator1`、 `iterator2` 等属性的值添加到 AST 的元素上。就我们的示例 `v-for="(item, index) in data"` 而言，解析出的的 `for ` 是 `data` ， `alias` 是 `item` ，`iterator1` 是 `index`，没有`iterator2`。

​				源码目录：`src/compiler/parser/index.js`

```js
function processIf (el) {
  const exp = getAndRemoveAttr(el, 'v-if')
  if (exp) {
    el.if = exp
    addIfCondition(el, {
      exp: exp,
      block: el
    })
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true
    }
    const elseif = getAndRemoveAttr(el, 'v-else-if')
    if (elseif) {
      el.elseif = elseif
    }
  }
}

export function addIfCondition (el: ASTElement, condition: ASTIfCondition) {
  if (!el.ifConditions) {
    el.ifConditions = []
  }
  el.ifConditions.push(condition)
}
```

​				`processIf` 就是从元素中拿 `v-if` 指令的内容，如果拿到则给 `AST` 元素添加` if` 属性和 `ifConditions` 属性;否则尝试拿 `v-else` 指令及 `v-else-if` 指令的内容，如果拿到则给 `AST` 元素分别添加 `else` 和 `elseif` 属性。

			##### 			2.4.3 `AST` 树管理

​				我们在处理开始标签的时候为每一个标签创建了一个 `AST` 元素，在不断解析模板创建 `AST` 元素的时候，我们也要为它们建立父子关系，就像 `DOM` 元素的父子关系那样。

​				源码目录：`src/compiler/parser/index.js`

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        `Cannot use <${el.tag}> as component root element because it may ` +
        'contain multiple nodes.',
        { start: el.start }
      )
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      )
    }
  }

  parseHTML(template, {
    //...
    start (tag, attrs, unary, start, end) {
			// ...
    	if (!root) {
        root = element
        if (process.env.NODE_ENV !== 'production') {
          checkRootConstraints(root)
        }
      }
      if (!unary) {
        currentParent = element
        stack.push(element)
      } else {
        closeElement(element)
      }
  	}
	})
  return root
}
```

​					`AST` 树管理的目标是构建一颗 `AST` 树，本质上它要维护 `root `根节点和当前父节点 `currentParent` 。为了保证元素可以正确闭合，这里也利用了 `stack` 栈的数据结构，和我们之前解析模板时用到的 `stack` 类似。

​					当我们在处理开始标签的时候，判断如果有`currentParent` ，会把当前 `AST` 元素 `push` 到`currentParent.children` 中，同时把 `AST` 元素的 `parent` 指向 `currentParent` 。 

​					接着就是更新 `currentParent` 和 `stack` ，判断当前如果不是一个一元标签，我们要把它生成的 `AST` 元素 `push` 到 `stack` 中，并且把当前的 `AST` 元素赋值给 `currentParent` 。

​					` stack` 和 `currentParent` 除了在处理开始标签的时候会变化，在处理闭合标签的时候也会变化，因此整个 `AST` 树管理要结合闭合标签的处理逻辑看。

#### 	2.5 处理闭合标签

​		对应伪代码:

```js
end () {
  treeManagement()
  closeElement()
}
```

​		当解析到闭合标签的时候，最后会执行 `end` 回调函数:

​		源码目录：`src/compiler/parser/index.js`

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  parseHTML(template, {
    //...
    end (tag, start, end) {
      const element = stack[stack.length - 1]
      // pop stack
      stack.length -= 1
      currentParent = stack[stack.length - 1]
      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
        element.end = end
      }
      closeElement(element)
    }
	})
  return root
}
```

​		首先处理了尾部空格的情况，然后把 `stack` 的元素弹一个出栈，并把 `stack` 最后一个元素赋值给 `currentParent`，这样就保证了当遇到闭合标签的时候，可以正确地更新 `stack` 的⻓度以及 `currentParent` 的值，这样就维护了整个 `AST` 树。 

​		最后执行了 `closeElement(elment)` :

​		源码目录：`src/compiler/parser/index.js`

```js
function closeElement (element) {
  trimEndingWhitespace(element)
  if (!inVPre && !element.processed) {
    element = processElement(element, options)
  }
  // tree management
  if (!stack.length && element !== root) {
    // allow root elements with v-if, v-else-if and v-else
    if (root.if && (element.elseif || element.else)) {
      if (process.env.NODE_ENV !== 'production') {
        checkRootConstraints(element)
      }
      addIfCondition(root, {
        exp: element.elseif,
        block: element
      })
    } else if (process.env.NODE_ENV !== 'production') {
      warnOnce(
        `Component template should contain exactly one root element. ` +
        `If you are using v-if on multiple elements, ` +
        `use v-else-if to chain them instead.`,
        { start: element.start }
      )
    }
  }
  if (currentParent && !element.forbidden) {
    if (element.elseif || element.else) {
      processIfConditions(element, currentParent)
    } else {
      if (element.slotScope) {
        // scoped slot
        // keep it in the children list so that v-else(-if) conditions can
        // find it as the prev node.
        const name = element.slotTarget || '"default"'
        ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
      }
      currentParent.children.push(element)
      element.parent = currentParent
    }
  }

  // final children cleanup
  // filter out scoped slots
  element.children = element.children.filter(c => !(c: any).slotScope)
  // remove trailing whitespace node again
  trimEndingWhitespace(element)

  // check pre state
  if (element.pre) {
    inVPre = false
  }
  if (platformIsPreTag(element.tag)) {
    inPre = false
  }
  // apply post-transforms
  for (let i = 0; i < postTransforms.length; i++) {
    postTransforms[i](element, options)
  }
}
```

​		`closeElement` 逻辑很简单，就是更新一下` inVPre` 和` inPre` 的状态，以及执行 `postTransforms` 函数。

#### 	2.6 处理文本内容

​		对应伪代码:

```js
chars (text: string) {
  handleText()
  createChildrenASTOfText()
}

```

​		除了处理开始标签和闭合标签，我们还会在解析模板的过程中去处理一些文本内容:

```js
/**
 * Convert HTML string to AST.
 */
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  // ...
  parseHTML(template, {
    //...
    chars (text: string, start: number, end: number) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start }
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text "${text}" outside root element will be ignored.`,
              { start }
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = ''
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' '
        } else {
          text = ' '
        }
      } else {
        text = preserveWhitespace ? ' ' : ''
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE, ' ')
        }
        let res
        let child: ?ASTNode
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text
          }
        }
        if (child) {
          if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    }
	})
  return root
}
```

​		文本构造的 `AST` 元素有 `2` 种类型，一种是有表达式的， `type` 为 `2`，一种是纯文本，`type` 为 `3`。在 我们的例子中，文本就是 `{{ item }}: {{ index }}` ，是个表达式，通过执行 `parseText(test, delimiters)` 对文本解析。

​		源码目录：`src/compiler/parser/text-parser.js`

```js
/* @flow */

import { cached } from 'shared/util'
import { parseFilters } from './filter-parser'

const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g
const regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g

const buildRegex = cached(delimiters => {
  const open = delimiters[0].replace(regexEscapeRE, '\\$&')
  const close = delimiters[1].replace(regexEscapeRE, '\\$&')
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})

type TextParseResult = {
  expression: string,
  tokens: Array<string | { '@binding': string }>
}

export function parseText (
  text: string,
  delimiters?: [string, string]
): TextParseResult | void {
  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
  if (!tagRE.test(text)) {
    return
  }
  const tokens = []
  const rawTokens = []
  let lastIndex = tagRE.lastIndex = 0
  let match, index, tokenValue
  while ((match = tagRE.exec(text))) {
    index = match.index
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    // tag token
    const exp = parseFilters(match[1].trim())
    tokens.push(`_s(${exp})`)
    rawTokens.push({ '@binding': exp })
    lastIndex = index + match[0].length
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex))
    tokens.push(JSON.stringify(tokenValue))
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

```

​		`parseText` 首先根据分隔符(默认是 `{{}}` )构造了文本匹配的正则表达式，然后再循环匹配文本，遇到普通文本就 `push` 到 `rawTokens` 和  `tokens` 中，如果是表达式就转换成 _s(${exp}) `push` 到 `tokens` 中，以及转换成 `{ '@binding': exp }` `push` 到 `rawTokens` 中。

​		对于我们的例子  `{{ item }}: {{ index }}`，`tokens` 就是 `[_s(item), '":"', _s(index))];` `rawTokens` 就是 `[{ '@binding':'item' },':',{'@binding':'index'}]` 。那么返回的对象如下：

```js
return {
  expression: '_s(item)+":"+_s(index)',
  tokens: [{'@binding':'item'},':',{'@binding':'index'}]
}
```





#### 	2.7 流程图

![](https://raw.githubusercontent.com/lotosv2010/Vue-SourceCode-Analysis/master/images/07/03-%E6%B5%81%E7%A8%8B%E5%9B%BE.png)



	#### 	2.8 总结

​		那么至此，`parse` 的过程就分析完了，看似复杂，但我们可以抛开细节理清它的整体流程。 `parse` 的目标是把 `template` 模板字符串转换成 `AST` 树，它是一种用 `JavaScript` 对象的形式来描述整个模板。那么整个 `parse` 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 `AST` 树的目的。

​		`AST` 元素节点总共有 `3` 种类型， `type` 为 `1` 表示是**普通元素**，为` 2` 表示是**表达式**，为 `3` 表示是**纯文本**。

​		当 `AST` 树构造完毕，下一步就是 `optimize` 优化这颗树。

### 3. `optimize`

​	当我们的模板 `template` 经过 `parse` 过程后，会输出生成 `AST` 树，那么接下来我们需要对这颗树做优化，  `optimize` 的逻辑是远简单于` parse` 的逻辑，所以理解起来会轻松很多。

​	为什么要有优化过程，因为我们知道 `Vue` 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 `DOM` 也不会变化，我们可以在 `patch` 的过程跳过对他们的比对。

​	源码目录：`src/compiler/optimizer.js`

```js
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // first pass: mark all non-static nodes.
  markStatic(root)
  // second pass: mark static roots.
  markStaticRoots(root, false)
}

function genStaticKeys (keys: string): Function {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}
```

​	我们在编译阶段可以把一些 `AST `节点优化成静态节点，所以整个 `optimize` 的过程实际上就干 2 件事情，`markStatic(root)` 标记静态节点 ，`markStaticRoots(root, false)` 标记静态根。

#### 	3.1 标记静态节点

​		源码目录：`src/compiler/optimizer.js`

```js
function markStatic (node: ASTNode) {
  node.static = isStatic(node)
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child)
      if (!child.static) {
        node.static = false
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
          node.static = false
        }
      }
    }
  }
}

function isStatic (node: ASTNode): boolean {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}
```

​		首先执行 `node.static = isStatic(node)`。

​		`isStatic` 是对一个` AST` 元素节点是否是静态的判断，如果是表达式，就是非静态;如果是纯文本，就是静态;对于一个普通元素，如果有 `pre` 属性，那么它使用了 `v-pre` 指令，是静态，否则要同时满足以下条件:

​			(1) 没有使用 `v-if` 、`v-for` 

​			(2) 没有使用其它指令(不包括 `v-once` )

​			(3) 非内置组件 

​			(4) 是平台保留的标签

​			(5) 非带有  `v-for` 的 `template` 标签的直接子节点

​			(5) 节点的所有属性的 `key` 都满足静态 key

​		这些都满足则这个 `AST` 节点是一个静态节点。

​		如果这个节点是一个普通元素，则遍历它的所有 `children` ，递归执行 `markStatic` 。因为所有的 `elseif` 和 `else` 节点都不在 `children` 中， 如果节点的 `ifConditions` 不为空，则遍历 `ifConditions` 拿到所有条件中的  `block`，也就是它们对应的 `AST` 节点，递归执行 `markStatic` 。在这些递归过程中，一旦子节点有不是 `static` 的情况，则它的父节点的` static` 均变成 `false`。

#### 	3.2 标记静态根

​		源码目录：`src/compiler/optimizer.js`

```js
function markStaticRoots (node: ASTNode, isInFor: boolean) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
    if (node.children) {
      for (let i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
      }
    }
  }
}
```

​		`markStaticRoots` 第二个参数是 `isInFor` ，对于已经是 `static` 的节点或者是 `v-once` 指令的节点，`node.staticInFor = isInFor` 。 接着就是对于 `staticRoot` 的判断逻辑，从注释中我们可以看到，对于有资格成为 `staticRoot` 的节点，除了本身是一个静态节点外，必须满足拥有 `children`	，并且 `children` 不能只是一个文本节点，不然的话把它标记成静态根节点的收益就很小了。 	

​		接下来和标记静态节点的逻辑一样，遍历 `children` 以及 `ifConditions` ，递归执行 `markStaticRoots` 。

​		回归我们之前的例子，经过 `optimize` 后，`AST` 树变成了如下:

```js
ast = {
  'type': 1,
  'tag': 'ul',
  'attrsList': [],
  'attrsMap': {
		':class': 'bindCls', 
    'class': 'list', 
    'v-if': 'isShow'
  },
  'if': 'isShow',
  'ifConditions': [{
    'exp': 'isShow',
    'block': // ul ast element
  }],
  'parent': undefined,
  'plain': false,
  'staticClass': 'list',
  'classBinding': 'bindCls',
  'static': false,
  'staticRoot': false,
  'children': [{
    'type': 1,
    'tag': 'li',
    'attrsList': [{
      'name': '@click',
      'value': 'clickItem(index)'
    }],
		'attrsMap': {
			'@click': 'clickItem(index)', 
      'v-for': '(item,index) in data'
     },
    'parent': // ul ast element
    'plain': false,
    'events': {
      'click': {
        'value': 'clickItem(index)'
			} 
		},
    'hasBindings': true,
    'for': 'data',
    'alias': 'item',
    'iterator1': 'index',
    'static': false,
    'staticRoot': false,
    'children': [
			'type': 2,
			'expression': '_s(item)+":"+_s(index)' 
      'text': '{{item}}:{{index}}', 
      'tokens': [
        {'@binding':'item'},
        ':',
        {'@binding':'index'}
			],
      'static': false
    ]
	}] 
}
```

​		我们发现每一个 `AST` 元素节点都多了 `staic` 属性，并且 `type` 为 `1` 的普通元素 `AST` 节点多了 `staticRoot` 属性。

#### 	3.3 总结

​		那么至此我们分析完了 `optimize` 的过程，就是深度遍历这个 `AST` 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 `DOM` 永远不需要改变，这对运行时对模板的更新起到极大的 优化作用。

​		我们通过 `optimize` 我们把整个 `AST` 树中的每一个 `AST` 元素节点标记了 `static` 和 `staticRoot` ，它会影响我们接下来执行代码生成的过程。

### 4. `codegen`

​	编译的最后一步就是把优化后的 `AST` 树转换成可执行的代码，这部分内容也比较多，我们了解整体流程即可。部分细节我们会在之后的章节配合一个具体 case 去详细讲。

​	为了方便理解，我们还是用之前的例子:

```html
<ul :class="bindCls" class="list" v-if="isShow">
	<li v-for="(item,index) in data" @click="clickItem(index)">{{item}}:{{index}}</li> 
</ul>
```

​	它经过编译，执行 `const code = generate(ast, options)` ，生成的 `render` 代码串如下:

```js
with(this){
  return (isShow) ?
    _c('ul', {
        staticClass: "list",
        class: bindCls
      },
      _l((data), function(item, index) {
      	return _c('li', { 
          on: {
            "click": function($event) {
              clickItem(index)
            } 
          }
      	},
      	[_v(_s(item) + ":" + _s(index))]) 
  		})
     ) : _e() 
	}
```

​	这里的 `_c`  就是 `createElement`。

​	源码目录：`src/core/indtance/render.js`

```js
 vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
```

​	而 `_l` 、` _v`  分别是 `renderList` 、`createTextVNode`。

​	源码目录：`src/core/indtance/render-helpers/index.js`

```js
/* @flow */

import { toNumber, toString, looseEqual, looseIndexOf } from 'shared/util'
import { createTextVNode, createEmptyVNode } from 'core/vdom/vnode'
import { renderList } from './render-list'
import { renderSlot } from './render-slot'
import { resolveFilter } from './resolve-filter'
import { checkKeyCodes } from './check-keycodes'
import { bindObjectProps } from './bind-object-props'
import { renderStatic, markOnce } from './render-static'
import { bindObjectListeners } from './bind-object-listeners'
import { resolveScopedSlots } from './resolve-scoped-slots'
import { bindDynamicKeys, prependModifier } from './bind-dynamic-keys'

export function installRenderHelpers (target: any) {
  target._o = markOnce
  target._n = toNumber
  target._s = toString
  target._l = renderList
  target._t = renderSlot
  target._q = looseEqual
  target._i = looseIndexOf
  target._m = renderStatic
  target._f = resolveFilter
  target._k = checkKeyCodes
  target._b = bindObjectProps
  target._v = createTextVNode
  target._e = createEmptyVNode
  target._u = resolveScopedSlots
  target._g = bindObjectListeners
  target._d = bindDynamicKeys
  target._p = prependModifier
}

```

​	顾名思义，`_c` 就是执行 `createElement` 去创建 `VNode`，而 `_l` 对应 `renderList` 渲染列表; ` _v` 对应 `createTextVNode` 创建文本 VNode; `_e` 对应 `createEmptyVNode` 创建空的`VNode`。

​	在 `compileToFunctions` 中，会把这个 `render` 代码串转换成函数。

​	源码目录：`src/compiler/to-function.js`

```js
const compiled = compile(template, options)
res.render = createFunction(compiled.render, fnGenErrors)

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}
```

​	实际上就是把 `render` 代码串通过 `new Function` 的方式转换成可执行的函数，赋值给 `vm.options.render`，这样当组件通过 `vm._render` 的时候，就会执行这个 `render `函数。那么接下来我们就重点关注一下这个 `render` 代码串的生成过程。

#### 	4.1 `generate`

​		源码目录：`src/compiler/index.js`

```js
/* @flow */

// ...
import { generate } from './codegen/index'
import { createCompilerCreator } from './create-compiler'

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // ...
  const code = generate(ast, options)
  // ...
})
```

​		源码目录：`src/compiler/codegen/index.js`

```js
export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c("div")'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
```

​		`generate` 函数首先通过 `genElement(ast, state)` 生成 `code` ，再把 `code` 用 `with(this){return ${code}}` 包裹起来。这里的 `state` 是 `CodegenState` 的一个实例，稍后我们在用到它的时候会介绍它。先来看一下 `genElement`。

​		源码目录：`src/compiler/codegen/index.js`

```js
export function genElement (el: ASTElement, state: CodegenState): string {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      let data
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData(el, state)
      }

      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
```

​		基本就是判断当前 `AST` 元素节点的属性执行不同的代码生成函数，在我们的例子中，我们先了解一下 `genFor` 和 `genIf` 。

#### 	4.2 `genIf`

​		源码目录：`src/compiler/codegen/index.js`

```js
export function genIf (
  el: any,
  state: CodegenState,
  altGen?: Function,
  altEmpty?: string
): string {
  el.ifProcessed = true // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions: ASTIfConditions,
  state: CodegenState,
  altGen?: Function,
  altEmpty?: string
): string {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  const condition = conditions.shift()
  if (condition.exp) {
    return `(${condition.exp})?${
      genTernaryExp(condition.block)
    }:${
      genIfConditions(conditions, state, altGen, altEmpty)
    }`
  } else {
    return `${genTernaryExp(condition.block)}`
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}
```

​		`genIf`  主要是通过执行 `genIfConditions` ，它是依次从 `conditions` 获取第一个 `condition` ， 然后通过对 `condition.exp` 去生成一段三元运算符的代码， `: ` 后是递归调用 `genIfConditions`，这样如果有多个 `conditions` ，就生成多层三元运算逻辑。这里我们暂时不考虑 `v-once` 的情况，所以 `genTernaryExp` 最终是调用了 `genElement` 。

​		在我们的例子中，只有一个 `condition` ，` exp` 为` isShow` ，因此生成如下伪代码:	

```js
 return (isShow) ? genElement(el, state) : _e()
```

#### 	4.3 `genFor`

​		源码目录：`src/compiler/codegen/index.js`

```js
export function genFor (
  el: any,
  state: CodegenState,
  altGen?: Function,
  altHelper?: string
): string {
  const exp = el.for
  const alias = el.alias
  const iterator1 = el.iterator1 ? `,${el.iterator1}` : ''
  const iterator2 = el.iterator2 ? `,${el.iterator2}` : ''

  if (process.env.NODE_ENV !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      `<${el.tag} v-for="${alias} in ${exp}">: component lists rendered with ` +
      `v-for should have explicit keys. ` +
      `See https://vuejs.org/guide/list.html#key for more info.`,
      el.rawAttrsMap['v-for'],
      true /* tip */
    )
  }

  el.forProcessed = true // avoid recursion
  return `${altHelper || '_l'}((${exp}),` +
    `function(${alias}${iterator1}${iterator2}){` +
      `return ${(altGen || genElement)(el, state)}` +
    '})'
}
```

​		`genFor` 的逻辑很简单，首先 `AST` 元素节点中获取了和 `for` 相关的一些属性，然后返回了一个代码字符串。

​		在我们的例子中， `exp` 是 `data` ， `alias` 是` item` ， `iterator1` ，因此生成如下伪代码:

```js
_l((data), function(item, index) { 
  return genElememt(el, state)
})
```

#### 	4.4 `genData`  `&`   `genChildren`

​		再次回顾我们的例子，它的最外层是 `ul` ，首先执行 `genIf` ，它最终调用了 `genElement(el, state)`  去生成子节点，注意，这里的 `el` 仍然指向的是` ul` 对应的 `AST` 节点，但是此时的 `el.ifProcessed` 为 `true`，所以命中最后一个 `else` 逻辑:

​	源码目录：`src/compiler/codegen/index.js`

```js

export function genElement (el: ASTElement, state: CodegenState): string {
  // ...
  if (el.staticRoot && !el.staticProcessed) {
    // ...
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      let data
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData(el, state)
      }

      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
```

​		这里我们只关注 `2` 个逻辑，` genData` 和 `genChildren` :

​			(1) ` genData`

​			源码目录：`src/compiler/codegen/index.js`

```js
export function genData (el: ASTElement, state: CodegenState): string {
  let data = '{'

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  const dirs = genDirectives(el, state)
  if (dirs) data += dirs + ','

  // key
  if (el.key) {
    data += `key:${el.key},`
  }
  // ref
  if (el.ref) {
    data += `ref:${el.ref},`
  }
  if (el.refInFor) {
    data += `refInFor:true,`
  }
  // pre
  if (el.pre) {
    data += `pre:true,`
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += `tag:"${el.tag}",`
  }
  // module data generation functions
  for (let i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el)
  }
  // attributes
  if (el.attrs) {
    data += `attrs:${genProps(el.attrs)},`
  }
  // DOM props
  if (el.props) {
    data += `domProps:${genProps(el.props)},`
  }
  // event handlers
  if (el.events) {
    data += `${genHandlers(el.events, false)},`
  }
  if (el.nativeEvents) {
    data += `${genHandlers(el.nativeEvents, true)},`
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += `slot:${el.slotTarget},`
  }
  // scoped slots
  if (el.scopedSlots) {
    data += `${genScopedSlots(el, el.scopedSlots, state)},`
  }
  // component v-model
  if (el.model) {
    data += `model:{value:${
      el.model.value
    },callback:${
      el.model.callback
    },expression:${
      el.model.expression
    }},`
  }
  // inline-template
  if (el.inlineTemplate) {
    const inlineTemplate = genInlineTemplate(el, state)
    if (inlineTemplate) {
      data += `${inlineTemplate},`
    }
  }
  data = data.replace(/,$/, '') + '}'
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = `_b(${data},"${el.tag}",${genProps(el.dynamicAttrs)})`
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data)
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data)
  }
  return data
}
```

​				`genData` 函数就是根据 `AST` 元素节点的属性构造出一个 `data` 对象字符串，这个在后面创建 `VNode` 的时候的时候会作为参数传入。

​				之前我们提到了 `CodegenState` 的实例 `state` ，这里有一段关于 `state` 的逻辑:

​				源码目录：`src/compiler/codegen/index.js`

```js
  // module data generation functions
  for (let i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el)
  }
```

​				`state.dataGenFns`  的初始化在它的构造器中。

```js
export class CodegenState {
  // ...

  constructor (options: CompilerOptions) {
    // ...
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData')
    // ...
  }
}
```

​				实际上就是获取所有 `modules` 中的 `genDatas` 函数，其中， `class module` 和 `style module`定义了 `genDatas` 函数。

​				源码目录：`src/platforms/web/compiler/modules/class.js`

```js
function genData (el: ASTElement): string {
  let data = ''
  if (el.staticClass) {
    data += `staticClass:${el.staticClass},`
  }
  if (el.classBinding) {
    data += `class:${el.classBinding},`
  }
  return data
}
```

​				在我们的例子中， `ul AST` 元素节点定义了` el.staticClass` 和 `el.classBinding` ，因此最终生成的 `data` 字符串如下:

```js
{
  staticClass: "list",
  class: bindCls
}
```



​			(2) `genChildren`

​				接下来我们再来看一下 `genChildren`。

​				源码目录：`src/compiler/codegen/index.js`

```js
export function genChildren (
  el: ASTElement,
  state: CodegenState,
  checkSkip?: boolean,
  altGenElement?: Function,
  altGenNode?: Function
): string | void {
  const children = el.children
  if (children.length) {
    const el: any = children[0]
    // optimize single v-for
    if (children.length === 1 &&
      el.for &&
      el.tag !== 'template' &&
      el.tag !== 'slot'
    ) {
      const normalizationType = checkSkip
        ? state.maybeComponent(el) ? `,1` : `,0`
        : ``
      return `${(altGenElement || genElement)(el, state)}${normalizationType}`
    }
    const normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0
    const gen = altGenNode || genNode
    return `[${children.map(c => gen(c, state)).join(',')}]${
      normalizationType ? `,${normalizationType}` : ''
    }`
  }
}
```

​				在我们的例子中，` li AST` 元素节点是 `ul AST` 元素节点的 `children` 之一，满足 `children.length === 1 && el.for && el.tag !== 'template' && el.tag !== 'slot'` 条件，因此通过 生成 `li AST` 元素节点的代码，也就回到了我们之前调用 `genFor` 生成的代码，把它们拼在一起生成的伪代码如下:

```js
return (isShow) ?
    _c('ul', {
        staticClass: "list",
        class: bindCls
  	},
		_l((data), function(item, index) {
    	return genElememt(el, state)
  	})
	) : _e()
```

​				在我们的例子中，在执行 `genElememt(el, state)` 的时候， `el` 还是 `li AST `元素节点，`el.forProcessed` 已为` true`，所以会继续执行` genData` 和 `genChildren` 的逻辑。由于 `el.events` 不为空，在执行 `genData` 的时候，会执行如下逻辑:

```js
if (el.events) {
	data += `${genHandlers(el.events, false, state.warn)},`
}
```

​				源码目录：`src/compiler/codegen/event.js`

```js
export function genHandlers (
  events: ASTElementHandlers,
  isNative: boolean
): string {
  const prefix = isNative ? 'nativeOn:' : 'on:'
  let staticHandlers = ``
  let dynamicHandlers = ``
  for (const name in events) {
    const handlerCode = genHandler(events[name])
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += `${name},${handlerCode},`
    } else {
      staticHandlers += `"${name}":${handlerCode},`
    }
  }
  staticHandlers = `{${staticHandlers.slice(0, -1)}}`
  if (dynamicHandlers) {
    return prefix + `_d(${staticHandlers},[${dynamicHandlers.slice(0, -1)}])`
  } else {
    return prefix + staticHandlers
  }
}

```

​				`genHandler` 的逻辑就不介绍了，很大部分都是对修饰符 `modifier` 的处理，感兴趣同学可以自己看，对于我们的例子，它最终 `genData` 生成的 `data` 字符串如下:

```js
{
  on: {
    "click": function($event) {
      clickItem(index)
    } 
  }
}
```

​				`genChildren` 的时候，会执行到如下逻辑:

​				源码目录：`src/compiler/codegen/index.js`

```js
export function genChildren (
  el: ASTElement,
  state: CodegenState,
  checkSkip?: boolean,
  altGenElement?: Function,
  altGenNode?: Function
): string | void {
  	// ...
    const normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0
    const gen = altGenNode || genNode
    return `[${children.map(c => gen(c, state)).join(',')}]${
      normalizationType ? `,${normalizationType}` : ''
    }`
  }
}

function genNode (node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

```

​				`genChildren` 的就是遍历 `children` ，然后执行 `genNode` 方法，根据不同的 `type` 执行具体的方法。在我们的例子中，` li AST` 元素节点的 `children` 是` type` 为 `2` 的表达式 `AST` 元素节点，那么会执行到 `genText(node)` 逻辑。		

​				源码目录：`src/compiler/codegen/index.js`

```js
export function genText (text: ASTText | ASTExpression): string {
  return `_v(${text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))
  })`
}
```

​				因此在我们的例子中， `genChildren` 生成的代码串如下:

```js
 [_v(_s(item) + ":" + _s(index))]
```

​				和之前拼在一起，最终生成的 `code `如下:

```js
return (isShow) ?
   _c('ul', {
       staticClass: "list",
       class: bindCls
    },
		_l((data), function(item, index) { 
  		return _c('li', {
         on: {
           "click": function($event) {
             clickItem(index)
           }
         }
			},
			[_v(_s(item) + ":" + _s(index))])
		})
	) : _e()
```

#### 	4.5 总结

​		这一节通过例子配合解析，我们对从 `ast -> code` 这一步有了一些了解，编译后生成的代码就是在 运行时执行的代码。由于 `genCode` 的内容有很多，所以我对大家的建议是没必要把所有的细节都一 次性看完，我们应该根据具体一个 `case`，走完一条主线即可。



















